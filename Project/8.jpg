ass DefinitionTranslator
{



private $translator;






public function __construct(TranslatorInterface $translator)
{
$this->translator = $translator;
}










public function translateDefinition(Suite $suite, Definition $definition, $language = null)
{
$assetsId = $suite->getName();
$pattern = $definition->getPattern();

$translatedPattern = $this->translator->trans($pattern, array(), $assetsId, $language);
if ($pattern != $translatedPattern) {
return new TranslatedDefinition($definition, $translatedPattern, $language);
}

return $definition;
}

public function getLocale()
{
return $this->translator->getLocale();
}
}
<?php









namespace Behat\Behat\Definition\Translator;

use Behat\Behat\Definition\Definition;






final class TranslatedDefinition implements Definition
{



private $definition;



private $translatedPattern;



private $language;








public function __construct(Definition $definition, $translatedPattern, $language)
{
$this->definition = $definition;
$this->translatedPattern = $translatedPattern;
$this->language = $language;
}




public function getType()
{
return $this->definition->getType();
}




public function getPattern()
{
return $this->translatedPattern;
}






public function getOriginalPattern()
{
return $this->definition->getPattern();
}






public function getLanguage()
{
return $this->language;
}




public function getDescription()
{
return $this->definition->getDescription();
}




public function getPath()
{
return $this->definition->getPath();
}




public function isAMethod()
{
return $this->definition->isAMethod();
}




public function isAnInstanceMethod()
{
return $this->definition->isAnInstanceMethod();
}




public function getCallable()
{
return $this->definition->getCallable();
}




public function getReflection()
{
return $this->definition->getReflection();
}




public function __toString()
{
return $this->definition->__toString();
}
}
<?php









namespace Behat\Behat\EventDispatcher\Cli;

use Behat\Behat\EventDispatcher\Event\AfterScenarioTested;
use Behat\Behat\EventDispatcher\Event\ExampleTested;
use Behat\Behat\EventDispatcher\Event\ScenarioTested;
use Behat\Testwork\Cli\Controller;
use Behat\Testwork\EventDispatcher\Event\AfterExerciseAborted;
use Behat\Testwork\EventDispatcher\Event\AfterSuiteAborted;
use Behat\Testwork\EventDispatcher\Event\ExerciseCompleted;
use Behat\Testwork\EventDispatcher\Event\SuiteTested;
use Behat\Testwork\Tester\Result\Interpretation\ResultInterpretation;
use Behat\Testwork\Tester\Result\Interpretation\SoftInterpretation;
use Behat\Testwork\Tester\Result\Interpretation\StrictInterpretation;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;






final class StopOnFailureController implements Controller
{



private $eventDispatcher;




private $resultInterpretation;






public function __construct(EventDispatcherInterface $eventDispatcher)
{
$this->eventDispatcher = $eventDispatcher;
$this->resultInterpretation = new SoftInterpretation();
}






public function configure(Command $command)
{
$command->addOption('--stop-on-failure', null, InputOption::VALUE_NONE,
'Stop processing on first failed scenario.'
);
}









public function execute(InputInterface $input, OutputInterface $output)
{
if (!$input->getOption('stop-on-failure')) {
return null;
}

if ($input->getOption('strict')) {
$this->resultInterpretation = new StrictInterpretation();
}

$this->eventDispatcher->addListener(ScenarioTested::AFTER, array($this, 'exitOnFailure'), -100);
$this->eventDispatcher->addListener(ExampleTested::AFTER, array($this, 'exitOnFailure'), -100);
}






public function exitOnFailure(AfterScenarioTested $event)
{
if (!$this->resultInterpretation->isFailure($event->getTestResult())) {
return;
}

$this->eventDispatcher->dispatch(SuiteTested::AFTER, new AfterSuiteAborted($event->getEnvironment()));
$this->eventDispatcher->dispatch(ExerciseCompleted::AFTER, new AfterExerciseAborted());

exit(1);
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\BackgroundNode;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\AfterSetup;
use Behat\Testwork\Tester\Setup\Setup;






final class AfterBackgroundSetup extends BackgroundTested implements AfterSetup
{



private $feature;



private $background;



private $setup;









public function __construct(Environment $env, FeatureNode $feature, BackgroundNode $background, Setup $setup)
{
parent::__construct($env);

$this->feature = $feature;
$this->background = $background;
$this->setup = $setup;
}






public function getFeature()
{
return $this->feature;
}






public function getScenario()
{
return $this->background;
}






public function getBackground()
{
return $this->background;
}






public function getSetup()
{
return $this->setup;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\BackgroundNode;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\AfterTested;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Setup\Teardown;






final class AfterBackgroundTested extends BackgroundTested implements AfterTested
{



private $feature;



private $background;



private $result;



private $teardown;










public function __construct(
Environment $env,
FeatureNode $feature,
BackgroundNode $background,
TestResult $result,
Teardown $teardown
) {
parent::__construct($env);

$this->feature = $feature;
$this->background = $background;
$this->result = $result;
$this->teardown = $teardown;
}






public function getFeature()
{
return $this->feature;
}






public function getScenario()
{
return $this->background;
}






public function getBackground()
{
return $this->background;
}






public function getTestResult()
{
return $this->result;
}






public function getTeardown()
{
return $this->teardown;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\AfterSetup;
use Behat\Testwork\Tester\Setup\Setup;






final class AfterFeatureSetup extends FeatureTested implements AfterSetup
{



private $feature;



private $setup;








public function __construct(Environment $env, FeatureNode $feature, Setup $setup)
{
parent::__construct($env);

$this->feature = $feature;
$this->setup = $setup;
}






public function getFeature()
{
return $this->feature;
}






public function getSetup()
{
return $this->setup;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\AfterTested;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Setup\Teardown;






final class AfterFeatureTested extends FeatureTested implements AfterTested
{



private $feature;



private $result;



private $teardown;









public function __construct(Environment $env, FeatureNode $feature, TestResult $result, Teardown $teardown)
{
parent::__construct($env);

$this->feature = $feature;
$this->result = $result;
$this->teardown = $teardown;
}






public function getFeature()
{
return $this->feature;
}






public function getTestResult()
{
return $this->result;
}






public function getTeardown()
{
return $this->teardown;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\AfterSetup;
use Behat\Testwork\Tester\Setup\Setup;






final class AfterOutlineSetup extends OutlineTested implements AfterSetup
{



private $feature;



private $outline;



private $setup;









public function __construct(Environment $env, FeatureNode $feature, OutlineNode $outline, Setup $setup)
{
parent::__construct($env);

$this->feature = $feature;
$this->outline = $outline;
$this->setup = $setup;
}






public function getFeature()
{
return $this->feature;
}






public function getOutline()
{
return $this->outline;
}






public function getSetup()
{
return $this->setup;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\AfterTested;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Setup\Teardown;






final class AfterOutlineTested extends OutlineTested implements AfterTested
{



private $feature;



private $outline;



private $result;



private $teardown;










public function __construct(
Environment $env,
FeatureNode $feature,
OutlineNode $outline,
TestResult $result,
Teardown $teardown
) {
parent::__construct($env);

$this->feature = $feature;
$this->outline = $outline;
$this->result = $result;
$this->teardown = $teardown;
}






public function getFeature()
{
return $this->feature;
}






public function getOutline()
{
return $this->outline;
}






public function getTestResult()
{
return $this->result;
}






public function getTeardown()
{
return $this->teardown;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Gherkin\Node\ScenarioNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\AfterSetup;
use Behat\Testwork\Tester\Setup\Setup;






final class AfterScenarioSetup extends ScenarioTested implements AfterSetup
{



private $feature;



private $scenario;



private $setup;









public function __construct(Environment $env, FeatureNode $feature, Scenario $scenario, Setup $setup)
{
parent::__construct($env);

$this->feature = $feature;
$this->scenario = $scenario;
$this->setup = $setup;
}






public function getFeature()
{
return $this->feature;
}






public function getScenario()
{
return $this->scenario;
}






public function getSetup()
{
return $this->setup;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Gherkin\Node\ScenarioNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\AfterTested;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Setup\Teardown;






final class AfterScenarioTested extends ScenarioTested implements AfterTested
{



private $feature;



private $scenario;



private $result;



private $teardown;










public function __construct(
Environment $env,
FeatureNode $feature,
Scenario $scenario,
TestResult $result,
Teardown $teardown
) {
parent::__construct($env);

$this->feature = $feature;
$this->scenario = $scenario;
$this->result = $result;
$this->teardown = $teardown;
}






public function getFeature()
{
return $this->feature;
}






public function getScenario()
{
return $this->scenario;
}






public function getTestResult()
{
return $this->result;
}






public function getTeardown()
{
return $this->teardown;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\AfterSetup;
use Behat\Testwork\Tester\Setup\Setup;






final class AfterStepSetup extends StepTested implements AfterSetup
{



private $feature;



private $step;



private $setup;









public function __construct(Environment $env, FeatureNode $feature, StepNode $step, Setup $setup)
{
parent::__construct($env);

$this->feature = $feature;
$this->step = $step;
$this->setup = $setup;
}






public function getFeature()
{
return $this->feature;
}






public function getStep()
{
return $this->step;
}






public function getSetup()
{
return $this->setup;
}






public function hasOutput()
{
return $this->setup->hasOutput();
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Behat\Tester\Result\ExecutedStepResult;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\AfterTested;
use Behat\Testwork\Tester\Result\ExceptionResult;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Setup\Teardown;






final class AfterStepTested extends StepTested implements AfterTested
{



private $feature;



private $step;



private $result;



private $teardown;










public function __construct(
Environment $env,
FeatureNode $feature,
StepNode $step,
StepResult $result,
Teardown $teardown
) {
parent::__construct($env);

$this->feature = $feature;
$this->step = $step;
$this->result = $result;
$this->teardown = $teardown;
}






public function getFeature()
{
return $this->feature;
}






public function getStep()
{
return $this->step;
}






public function getTestResult()
{
return $this->result;
}






public function getTeardown()
{
return $this->teardown;
}






public function hasOutput()
{
return $this->teardownHasOutput() || $this->resultHasException() || $this->resultCallHasOutput();
}






private function teardownHasOutput()
{
return $this->teardown->hasOutput();
}






private function resultHasException()
{
return $this->result instanceof ExceptionResult && $this->result->getException();
}






private function resultCallHasOutput()
{
if (!$this->result instanceof ExecutedStepResult) {
return false;
}

return $this->result->getCallResult()->hasStdOut() || $this->result->getCallResult()->hasException();
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\BackgroundNode;
use Behat\Gherkin\Node\NodeInterface;
use Behat\Testwork\EventDispatcher\Event\LifecycleEvent;






abstract class BackgroundTested extends LifecycleEvent implements ScenarioLikeTested
{
const BEFORE = 'tester.background_tested.before';
const AFTER_SETUP = 'tester.background_tested.after_setup';
const BEFORE_TEARDOWN = 'tester.background_tested.before_teardown';
const AFTER = 'tester.background_tested.after';






abstract public function getBackground();






final public function getNode()
{
return $this->getBackground();
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\BackgroundNode;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\BeforeTeardown;
use Behat\Testwork\Tester\Result\TestResult;






final class BeforeBackgroundTeardown extends BackgroundTested implements BeforeTeardown
{



private $feature;



private $background;



private $result;









public function __construct(
Environment $env,
FeatureNode $feature,
BackgroundNode $background,
TestResult $result
) {
parent::__construct($env);

$this->feature = $feature;
$this->background = $background;
$this->result = $result;
}






public function getFeature()
{
return $this->feature;
}






public function getScenario()
{
return $this->background;
}






public function getBackground()
{
return $this->background;
}






public function getTestResult()
{
return $this->result;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\BackgroundNode;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\BeforeTested;






final class BeforeBackgroundTested extends BackgroundTested implements BeforeTested
{



private $feature;



private $background;








public function __construct(Environment $env, FeatureNode $feature, BackgroundNode $background)
{
parent::__construct($env);

$this->feature = $feature;
$this->background = $background;
}






public function getFeature()
{
return $this->feature;
}






public function getScenario()
{
return $this->background;
}






public function getBackground()
{
return $this->background;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\BeforeTeardown;
use Behat\Testwork\Tester\Result\TestResult;






final class BeforeFeatureTeardown extends FeatureTested implements BeforeTeardown
{



private $feature;



private $result;








public function __construct(Environment $env, FeatureNode $feature, TestResult $result)
{
parent::__construct($env);

$this->feature = $feature;
$this->result = $result;
}






public function getFeature()
{
return $this->feature;
}






public function getTestResult()
{
return $this->result;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\BeforeTested;






final class BeforeFeatureTested extends FeatureTested implements BeforeTested
{



private $feature;







public function __construct(Environment $env, FeatureNode $feature)
{
parent::__construct($env);

$this->feature = $feature;
}






public function getFeature()
{
return $this->feature;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\BeforeTeardown;
use Behat\Testwork\Tester\Result\TestResult;






final class BeforeOutlineTeardown extends OutlineTested implements BeforeTeardown
{



private $feature;



private $outline;



private $result;









public function __construct(
Environment $env,
FeatureNode $feature,
OutlineNode $outline,
TestResult $result
) {
parent::__construct($env);

$this->feature = $feature;
$this->outline = $outline;
$this->result = $result;
}






public function getFeature()
{
return $this->feature;
}






public function getOutline()
{
return $this->outline;
}






public function getTestResult()
{
return $this->result;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\BeforeTested;






final class BeforeOutlineTested extends OutlineTested implements BeforeTested
{



private $feature;



private $outline;








public function __construct(Environment $env, FeatureNode $feature, OutlineNode $outline)
{
parent::__construct($env);

$this->feature = $feature;
$this->outline = $outline;
}






public function getFeature()
{
return $this->feature;
}






public function getOutline()
{
return $this->outline;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Gherkin\Node\ScenarioNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\BeforeTeardown;
use Behat\Testwork\Tester\Result\TestResult;






final class BeforeScenarioTeardown extends ScenarioTested implements BeforeTeardown
{



private $feature;



private $scenario;



private $result;









public function __construct(
Environment $env,
FeatureNode $feature,
Scenario $scenario,
TestResult $result
) {
parent::__construct($env);

$this->feature = $feature;
$this->scenario = $scenario;
$this->result = $result;
}






public function getFeature()
{
return $this->feature;
}






public function getScenario()
{
return $this->scenario;
}






public function getTestResult()
{
return $this->result;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Gherkin\Node\ScenarioNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\BeforeTested;






final class BeforeScenarioTested extends ScenarioTested implements BeforeTested
{



private $feature;



private $scenario;








public function __construct(Environment $env, FeatureNode $feature, Scenario $scenario)
{
parent::__construct($env);

$this->feature = $feature;
$this->scenario = $scenario;
}






public function getFeature()
{
return $this->feature;
}






public function getScenario()
{
return $this->scenario;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Behat\Tester\Result\ExecutedStepResult;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\BeforeTeardown;
use Behat\Testwork\Tester\Result\ExceptionResult;
use Behat\Testwork\Tester\Result\TestResult;






final class BeforeStepTeardown extends StepTested implements BeforeTeardown
{



private $feature;



private $step;



private $result;









public function __construct(
Environment $env,
FeatureNode $feature,
StepNode $step,
StepResult $result
) {
parent::__construct($env);

$this->feature = $feature;
$this->step = $step;
$this->result = $result;
}






public function getFeature()
{
return $this->feature;
}






public function getStep()
{
return $this->step;
}






public function getTestResult()
{
return $this->result;
}






public function hasOutput()
{
return $this->resultHasException() || $this->resultCallHasOutput();
}






private function resultHasException()
{
return $this->result instanceof ExceptionResult && $this->result->getException();
}






private function resultCallHasOutput()
{
if (!$this->result instanceof ExecutedStepResult) {
return false;
}

return $this->result->getCallResult()->hasStdOut() || $this->result->getCallResult()->hasException();
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\EventDispatcher\Event\BeforeTested;






final class BeforeStepTested extends StepTested implements BeforeTested
{



private $feature;



private $step;








public function __construct(Environment $env, FeatureNode $feature, StepNode $step)
{
parent::__construct($env);

$this->feature = $feature;
$this->step = $step;
}






public function getFeature()
{
return $this->feature;
}






public function getStep()
{
return $this->step;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;






interface ExampleTested
{
const BEFORE = 'tester.example_tested.before';
const AFTER_SETUP = 'tester.example_tested.after_setup';
const BEFORE_TEARDOWN = 'tester.example_tested.before_teardown';
const AFTER = 'tester.example_tested.after';
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\NodeInterface;
use Behat\Testwork\EventDispatcher\Event\LifecycleEvent;






abstract class FeatureTested extends LifecycleEvent implements GherkinNodeTested
{
const BEFORE = 'tester.feature_tested.before';
const AFTER_SETUP = 'tester.feature_tested.after_setup';
const BEFORE_TEARDOWN = 'tester.feature_tested.before_teardown';
const AFTER = 'tester.feature_tested.after';






abstract public function getFeature();






final public function getNode()
{
return $this->getFeature();
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\NodeInterface;






interface GherkinNodeTested
{





public function getNode();
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\NodeInterface;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\EventDispatcher\Event\LifecycleEvent;






abstract class OutlineTested extends LifecycleEvent implements GherkinNodeTested
{
const BEFORE = 'tester.outline_tested.before';
const AFTER_SETUP = 'tester.outline_tested.after_setup';
const BEFORE_TEARDOWN = 'tester.outline_tested.before_teardown';
const AFTER = 'tester.outline_tested.after';






abstract public function getFeature();






abstract public function getOutline();






final public function getNode()
{
return $this->getOutline();
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface;






interface ScenarioLikeTested extends GherkinNodeTested
{





public function getFeature();






public function getScenario();
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Testwork\EventDispatcher\Event\LifecycleEvent;






abstract class ScenarioTested extends LifecycleEvent implements ScenarioLikeTested
{
const BEFORE = 'tester.scenario_tested.before';
const AFTER_SETUP = 'tester.scenario_tested.after_setup';
const BEFORE_TEARDOWN = 'tester.scenario_tested.before_teardown';
const AFTER = 'tester.scenario_tested.after';




final public function getNode()
{
return $this->getScenario();
}
}
<?php









namespace Behat\Behat\EventDispatcher\Event;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\EventDispatcher\Event\LifecycleEvent;






abstract class StepTested extends LifecycleEvent implements GherkinNodeTested
{
const BEFORE = 'tester.step_tested.before';
const AFTER_SETUP = 'tester.step_tested.after_setup';
const BEFORE_TEARDOWN = 'tester.step_tested.before_teardown';
const AFTER = 'tester.step_tested.after';






abstract public function getFeature();






abstract public function getStep();




final public function getNode()
{
return $this->getStep();
}
}
<?php









namespace Behat\Behat\EventDispatcher\ServiceContainer;

use Behat\Behat\EventDispatcher\Event\ExampleTested;
use Behat\Behat\EventDispatcher\Event\ScenarioTested;
use Behat\Behat\Tester\ServiceContainer\TesterExtension;
use Behat\Testwork\Cli\ServiceContainer\CliExtension;
use Behat\Testwork\EventDispatcher\ServiceContainer\EventDispatcherExtension as BaseExtension;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Definition;
use Symfony\Component\DependencyInjection\Reference;






class EventDispatcherExtension extends BaseExtension
{



public function load(ContainerBuilder $container, array $config)
{
parent::load($container, $config);

$this->loadStopOnFailureController($container);
$this->loadEventDispatchingBackgroundTester($container);
$this->loadEventDispatchingFeatureTester($container);
$this->loadEventDispatchingOutlineTester($container);
$this->loadEventDispatchingScenarioTester($container);
$this->loadEventDispatchingExampleTester($container);
$this->loadEventDispatchingStepTester($container);
$this->loadTickingStepTester($container);
}






protected function loadStopOnFailureController(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\EventDispatcher\Cli\StopOnFailureController', array(
new Reference(EventDispatcherExtension::DISPATCHER_ID)
));
$definition->addTag(CliExtension::CONTROLLER_TAG, array('priority' => 100));
$container->setDefinition(CliExtension::CONTROLLER_TAG . '.stop_on_failure', $definition);
}






protected function loadEventDispatchingBackgroundTester(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\EventDispatcher\Tester\EventDispatchingBackgroundTester', array(
new Reference(TesterExtension::BACKGROUND_TESTER_ID),
new Reference(self::DISPATCHER_ID)
));
$definition->addTag(TesterExtension::BACKGROUND_TESTER_WRAPPER_TAG, array('priority' => -9999));
$container->setDefinition(TesterExtension::BACKGROUND_TESTER_WRAPPER_TAG . '.event_dispatching', $definition);
}






protected function loadEventDispatchingFeatureTester(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\EventDispatcher\Tester\EventDispatchingFeatureTester', array(
new Reference(TesterExtension::SPECIFICATION_TESTER_ID),
new Reference(self::DISPATCHER_ID)
));
$definition->addTag(TesterExtension::SPECIFICATION_TESTER_WRAPPER_TAG, array('priority' => -9999));
$container->setDefinition(TesterExtension::SPECIFICATION_TESTER_WRAPPER_TAG . '.event_dispatching', $definition);
}






protected function loadEventDispatchingOutlineTester(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\EventDispatcher\Tester\EventDispatchingOutlineTester', array(
new Reference(TesterExtension::OUTLINE_TESTER_ID),
new Reference(self::DISPATCHER_ID)
));
$definition->addTag(TesterExtension::OUTLINE_TESTER_WRAPPER_TAG, array('priority' => -9999));
$container->setDefinition(TesterExtension::OUTLINE_TESTER_WRAPPER_TAG . '.event_dispatching', $definition);
}






protected function loadEventDispatchingScenarioTester(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\EventDispatcher\Tester\EventDispatchingScenarioTester', array(
new Reference(TesterExtension::SCENARIO_TESTER_ID),
new Reference(self::DISPATCHER_ID),
ScenarioTested::BEFORE,
ScenarioTested::AFTER_SETUP,
ScenarioTested::BEFORE_TEARDOWN,
ScenarioTested::AFTER
));
$definition->addTag(TesterExtension::SCENARIO_TESTER_WRAPPER_TAG, array('priority' => -9999));
$container->setDefinition(TesterExtension::SCENARIO_TESTER_WRAPPER_TAG . '.event_dispatching', $definition);
}






protected function loadEventDispatchingExampleTester(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\EventDispatcher\Tester\EventDispatchingScenarioTester', array(
new Reference(TesterExtension::EXAMPLE_TESTER_ID),
new Reference(self::DISPATCHER_ID),
ExampleTested::BEFORE,
ExampleTested::AFTER_SETUP,
ExampleTested::BEFORE_TEARDOWN,
ExampleTested::AFTER
));
$definition->addTag(TesterExtension::EXAMPLE_TESTER_WRAPPER_TAG, array('priority' => -9999));
$container->setDefinition(TesterExtension::EXAMPLE_TESTER_WRAPPER_TAG . '.event_dispatching', $definition);
}






protected function loadEventDispatchingStepTester(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\EventDispatcher\Tester\EventDispatchingStepTester', array(
new Reference(TesterExtension::STEP_TESTER_ID),
new Reference(self::DISPATCHER_ID)
));
$definition->addTag(TesterExtension::STEP_TESTER_WRAPPER_TAG, array('priority' => -9999));
$container->setDefinition(TesterExtension::STEP_TESTER_WRAPPER_TAG . '.event_dispatching', $definition);
}






protected function loadTickingStepTester(ContainerBuilder $container)
{
if (!function_exists('pcntl_signal')) {
return;
}

$definition = new Definition('Behat\Behat\EventDispatcher\Tester\TickingStepTester', array(
new Reference(TesterExtension::STEP_TESTER_ID)
));
$definition->addTag(TesterExtension::STEP_TESTER_WRAPPER_TAG, array('priority' => 9999));
$container->setDefinition(TesterExtension::STEP_TESTER_WRAPPER_TAG . '.ticking', $definition);
}
}
<?php









namespace Behat\Behat\EventDispatcher\Tester;

use Behat\Behat\EventDispatcher\Event\AfterBackgroundSetup;
use Behat\Behat\EventDispatcher\Event\AfterBackgroundTested;
use Behat\Behat\EventDispatcher\Event\BackgroundTested;
use Behat\Behat\EventDispatcher\Event\BeforeBackgroundTeardown;
use Behat\Behat\EventDispatcher\Event\BeforeBackgroundTested;
use Behat\Behat\Tester\BackgroundTester;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Tester\Result\TestResult;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;






final class EventDispatchingBackgroundTester implements BackgroundTester
{



private $baseTester;



private $eventDispatcher;







public function __construct(BackgroundTester $baseTester, EventDispatcherInterface $eventDispatcher)
{
$this->baseTester = $baseTester;
$this->eventDispatcher = $eventDispatcher;
}




public function setUp(Environment $env, FeatureNode $feature, $skip)
{
$event = new BeforeBackgroundTested($env, $feature, $feature->getBackground());
$this->eventDispatcher->dispatch($event::BEFORE, $event);

$setup = $this->baseTester->setUp($env, $feature, $skip);

$event = new AfterBackgroundSetup($env, $feature, $feature->getBackground(), $setup);
$this->eventDispatcher->dispatch($event::AFTER_SETUP, $event);

return $setup;
}




public function test(Environment $env, FeatureNode $feature, $skip)
{
return $this->baseTester->test($env, $feature, $skip);
}




public function tearDown(Environment $env, FeatureNode $feature, $skip, TestResult $result)
{
$event = new BeforeBackgroundTeardown($env, $feature, $feature->getBackground(), $result);
$this->eventDispatcher->dispatch(BackgroundTested::BEFORE_TEARDOWN, $event);

$teardown = $this->baseTester->tearDown($env, $feature, $skip, $result);

$event = new AfterBackgroundTested($env, $feature, $feature->getBackground(), $result, $teardown);
$this->eventDispatcher->dispatch(BackgroundTested::AFTER, $event);

return $teardown;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Tester;

use Behat\Behat\EventDispatcher\Event\AfterFeatureSetup;
use Behat\Behat\EventDispatcher\Event\AfterFeatureTested;
use Behat\Behat\EventDispatcher\Event\BeforeFeatureTeardown;
use Behat\Behat\EventDispatcher\Event\BeforeFeatureTested;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\SpecificationTester;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;






final class EventDispatchingFeatureTester implements SpecificationTester
{



private $baseTester;



private $eventDispatcher;







public function __construct(SpecificationTester $baseTester, EventDispatcherInterface $eventDispatcher)
{
$this->baseTester = $baseTester;
$this->eventDispatcher = $eventDispatcher;
}




public function setUp(Environment $env, $feature, $skip)
{
$event = new BeforeFeatureTested($env, $feature);
$this->eventDispatcher->dispatch($event::BEFORE, $event);

$setup = $this->baseTester->setUp($env, $feature, $skip);

$event = new AfterFeatureSetup($env, $feature, $setup);
$this->eventDispatcher->dispatch($event::AFTER_SETUP, $event);

return $setup;
}




public function test(Environment $env, $feature, $skip)
{
return $this->baseTester->test($env, $feature, $skip);
}




public function tearDown(Environment $env, $feature, $skip, TestResult $result)
{
$event = new BeforeFeatureTeardown($env, $feature, $result);
$this->eventDispatcher->dispatch($event::BEFORE_TEARDOWN, $event);

$teardown = $this->baseTester->tearDown($env, $feature, $skip, $result);

$event = new AfterFeatureTested($env, $feature, $result, $teardown);
$this->eventDispatcher->dispatch($event::AFTER, $event);

return $teardown;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Tester;

use Behat\Behat\EventDispatcher\Event\AfterOutlineSetup;
use Behat\Behat\EventDispatcher\Event\AfterOutlineTested;
use Behat\Behat\EventDispatcher\Event\BeforeOutlineTeardown;
use Behat\Behat\EventDispatcher\Event\BeforeOutlineTested;
use Behat\Behat\Tester\OutlineTester;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Tester\Result\TestResult;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;






final class EventDispatchingOutlineTester implements OutlineTester
{



private $baseTester;



private $eventDispatcher;







public function __construct(OutlineTester $baseTester, EventDispatcherInterface $eventDispatcher)
{
$this->baseTester = $baseTester;
$this->eventDispatcher = $eventDispatcher;
}




public function setUp(Environment $env, FeatureNode $feature, OutlineNode $outline, $skip)
{
$event = new BeforeOutlineTested($env, $feature, $outline);
$this->eventDispatcher->dispatch($event::BEFORE, $event);

$setup = $this->baseTester->setUp($env, $feature, $outline, $skip);

$event = new AfterOutlineSetup($env, $feature, $outline, $setup);
$this->eventDispatcher->dispatch($event::AFTER_SETUP, $event);

return $setup;
}




public function test(Environment $env, FeatureNode $feature, OutlineNode $outline, $skip)
{
return $this->baseTester->test($env, $feature, $outline, $skip);
}




public function tearDown(Environment $env, FeatureNode $feature, OutlineNode $outline, $skip, TestResult $result)
{
$event = new BeforeOutlineTeardown($env, $feature, $outline, $result);
$this->eventDispatcher->dispatch($event::BEFORE_TEARDOWN, $event);

$teardown = $this->baseTester->tearDown($env, $feature, $outline, $skip, $result);

$event = new AfterOutlineTested($env, $feature, $outline, $result, $teardown);
$this->eventDispatcher->dispatch($event::AFTER, $event);

return $teardown;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Tester;

use Behat\Behat\EventDispatcher\Event\AfterScenarioSetup;
use Behat\Behat\EventDispatcher\Event\AfterScenarioTested;
use Behat\Behat\EventDispatcher\Event\BeforeScenarioTeardown;
use Behat\Behat\EventDispatcher\Event\BeforeScenarioTested;
use Behat\Behat\Tester\ScenarioTester;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface as Scenario;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Tester\Result\TestResult;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;






final class EventDispatchingScenarioTester implements ScenarioTester
{



private $baseTester;



private $eventDispatcher;



private $beforeEventName;



private $afterSetupEventName;



private $beforeTeardownEventName;



private $afterEventName;











public function __construct(
ScenarioTester $baseTester,
EventDispatcherInterface $eventDispatcher,
$beforeEventName,
$afterSetupEventName,
$beforeTeardownEventName,
$afterEventName
) {
$this->baseTester = $baseTester;
$this->eventDispatcher = $eventDispatcher;
$this->beforeEventName = $beforeEventName;
$this->afterSetupEventName = $afterSetupEventName;
$this->beforeTeardownEventName = $beforeTeardownEventName;
$this->afterEventName = $afterEventName;
}




public function setUp(Environment $env, FeatureNode $feature, Scenario $scenario, $skip)
{
$event = new BeforeScenarioTested($env, $feature, $scenario);
$this->eventDispatcher->dispatch($this->beforeEventName, $event);

$setup = $this->baseTester->setUp($env, $feature, $scenario, $skip);

$event = new AfterScenarioSetup($env, $feature, $scenario, $setup);
$this->eventDispatcher->dispatch($this->afterSetupEventName, $event);

return $setup;
}




public function test(Environment $env, FeatureNode $feature, Scenario $scenario, $skip)
{
return $this->baseTester->test($env, $feature, $scenario, $skip);
}




public function tearDown(Environment $env, FeatureNode $feature, Scenario $scenario, $skip, TestResult $result)
{
$event = new BeforeScenarioTeardown($env, $feature, $scenario, $result);
$this->eventDispatcher->dispatch($this->beforeTeardownEventName, $event);

$teardown = $this->baseTester->tearDown($env, $feature, $scenario, $skip, $result);

$event = new AfterScenarioTested($env, $feature, $scenario, $result, $teardown);
$this->eventDispatcher->dispatch($this->afterEventName, $event);

return $teardown;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Tester;

use Behat\Behat\EventDispatcher\Event\AfterStepSetup;
use Behat\Behat\EventDispatcher\Event\AfterStepTested;
use Behat\Behat\EventDispatcher\Event\BeforeStepTeardown;
use Behat\Behat\EventDispatcher\Event\BeforeStepTested;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Behat\Tester\StepTester;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Environment\Environment;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;






final class EventDispatchingStepTester implements StepTester
{



private $baseTester;



private $eventDispatcher;







public function __construct(StepTester $baseTester, EventDispatcherInterface $eventDispatcher)
{
$this->baseTester = $baseTester;
$this->eventDispatcher = $eventDispatcher;
}




public function setUp(Environment $env, FeatureNode $feature, StepNode $step, $skip)
{
$event = new BeforeStepTested($env, $feature, $step);
$this->eventDispatcher->dispatch($event::BEFORE, $event);

$setup = $this->baseTester->setUp($env, $feature, $step, $skip);

$event = new AfterStepSetup($env, $feature, $step, $setup);
$this->eventDispatcher->dispatch($event::AFTER_SETUP, $event);

return $setup;
}




public function test(Environment $env, FeatureNode $feature, StepNode $step, $skip)
{
return $this->baseTester->test($env, $feature, $step, $skip);
}




public function tearDown(Environment $env, FeatureNode $feature, StepNode $step, $skip, StepResult $result)
{
$event = new BeforeStepTeardown($env, $feature, $step, $result);
$this->eventDispatcher->dispatch($event::BEFORE_TEARDOWN, $event);

$teardown = $this->baseTester->tearDown($env, $feature, $step, $skip, $result);

$event = new AfterStepTested($env, $feature, $step, $result, $teardown);
$this->eventDispatcher->dispatch($event::AFTER, $event);

return $teardown;
}
}
<?php









namespace Behat\Behat\EventDispatcher\Tester;

use Behat\Behat\Tester\Result\StepResult;
use Behat\Behat\Tester\StepTester;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Environment\Environment;









final class TickingStepTester implements StepTester
{



private $baseTester;






public function __construct(StepTester $baseTester)
{
$this->baseTester = $baseTester;
}




public function setUp(Environment $env, FeatureNode $feature, StepNode $step, $skip)
{
return $this->baseTester->setUp($env, $feature, $step, $skip);
}




public function test(Environment $env, FeatureNode $feature, StepNode $step, $skip)
{
declare(ticks = 1);

return $this->baseTester->test($env, $feature, $step, $skip);
}




public function tearDown(Environment $env, FeatureNode $feature, StepNode $step, $skip, StepResult $result)
{
return $this->baseTester->tearDown($env, $feature, $step, $skip, $result);
}
}
<?php









namespace Behat\Behat\Gherkin\Cli;

use Behat\Gherkin\Filter\NameFilter;
use Behat\Gherkin\Filter\RoleFilter;
use Behat\Gherkin\Filter\TagFilter;
use Behat\Gherkin\Gherkin;
use Behat\Testwork\Cli\Controller;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;






final class FilterController implements Controller
{



private $gherkin;






public function __construct(Gherkin $gherkin)
{
$this->gherkin = $gherkin;
}






public function configure(Command $command)
{
$command
->addOption(
'--name', null, InputOption::VALUE_REQUIRED | InputOption::VALUE_IS_ARRAY,
"Only executeCall the feature elements which match part" . PHP_EOL .
"of the given name or regex."
)
->addOption(
'--tags', null, InputOption::VALUE_REQUIRED | InputOption::VALUE_IS_ARRAY,
"Only executeCall the features or scenarios with tags" . PHP_EOL .
"matching tag filter expression."
)
->addOption(
'--role', null, InputOption::VALUE_REQUIRED,
"Only executeCall the features with actor role matching" . PHP_EOL .
"a wildcard."
);
}









public function execute(InputInterface $input, OutputInterface $output)
{
$filters = array();

foreach ($input->getOption('name') as $name) {
$filters[] = new NameFilter($name);
}

foreach ($input->getOption('tags') as $tags) {
$filters[] = new TagFilter($tags);
}

if ($role = $input->getOption('role')) {
$filters[] = new RoleFilter($role);
}

if (count($filters)) {
$this->gherkin->setFilters($filters);
}
}
}
<?php









namespace Behat\Behat\Gherkin\Cli;

use Behat\Gherkin\Keywords\KeywordsDumper;
use Behat\Testwork\Cli\Controller;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Formatter\OutputFormatterStyle;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Translation\TranslatorInterface;






final class SyntaxController implements Controller
{



private $keywordsDumper;



private $translator;







public function __construct(KeywordsDumper $dumper, TranslatorInterface $translator)
{
$dumper->setKeywordsDumperFunction(array($this, 'dumpKeywords'));
$this->keywordsDumper = $dumper;
$this->translator = $translator;
}






public function configure(Command $command)
{
$command
->addOption(
'--story-syntax', null, InputOption::VALUE_NONE,
"Print <comment>*.feature</comment> example." . PHP_EOL .
"Use <info>--lang</info> to see specific language."
);
}









public function execute(InputInterface $input, OutputInterface $output)
{
if (!$input->getOption('story-syntax')) {
return null;
}

$output->getFormatter()->setStyle('gherkin_keyword', new OutputFormatterStyle('green', null, array('bold')));
$output->getFormatter()->setStyle('gherkin_comment', new OutputFormatterStyle('yellow'));

$story = $this->keywordsDumper->dump($this->translator->getLocale());
$story = preg_replace('/^\#.*/', '<gherkin_comment>$0</gherkin_comment>', $story);
$output->writeln($story);
$output->writeln('');

return 0;
}








public function dumpKeywords(array $keywords)
{
$dump = '<gherkin_keyword>' . implode('</gherkin_keyword>|<gherkin_keyword>', $keywords) . '</gherkin_keyword>';

if (1 < count($keywords)) {
return '[' . $dump . ']';
}

return $dump;
}
}
<?php









namespace Behat\Behat\Gherkin\ServiceContainer;

use Behat\Testwork\Cli\ServiceContainer\CliExtension;
use Behat\Testwork\Filesystem\ServiceContainer\FilesystemExtension;
use Behat\Testwork\ServiceContainer\Exception\ExtensionException;
use Behat\Testwork\ServiceContainer\Extension;
use Behat\Testwork\ServiceContainer\ExtensionManager;
use Behat\Testwork\ServiceContainer\ServiceProcessor;
use Behat\Testwork\Specification\ServiceContainer\SpecificationExtension;
use Behat\Testwork\Suite\ServiceContainer\SuiteExtension;
use Behat\Testwork\Translator\ServiceContainer\TranslatorExtension;
use ReflectionClass;
use Symfony\Component\Config\Definition\Builder\ArrayNodeDefinition;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Definition;
use Symfony\Component\DependencyInjection\Reference;






final class GherkinExtension implements Extension
{



const MANAGER_ID = 'gherkin';
const KEYWORDS_DUMPER_ID = 'gherkin.keywords_dumper';
const KEYWORDS_ID = 'gherkin.keywords';




const LOADER_TAG = 'gherkin.loader';




private $processor;






public function __construct(ServiceProcessor $processor = null)
{
$this->processor = $processor ? : new ServiceProcessor();
}




public function getConfigKey()
{
return 'gherkin';
}




public function initialize(ExtensionManager $extensionManager)
{
}




public function configure(ArrayNodeDefinition $builder)
{
$builder
->addDefaultsIfNotSet()
->children()
->scalarNode('cache')
->info('Sets the gherkin parser cache folder')
->defaultValue(
is_writable(sys_get_temp_dir())
? sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'behat_gherkin_cache'
: null
)
->end()
->arrayNode('filters')
->info('Sets the gherkin filters (overridable by CLI options)')
->performNoDeepMerging()
->defaultValue(array())
->useAttributeAsKey('name')
->prototype('scalar')->end()
->end()
->end()
;
}




public function load(ContainerBuilder $container, array $config)
{
$this->loadParameters($container);
$this->loadGherkin($container);
$this->loadKeywords($container);
$this->loadParser($container);
$this->loadDefaultLoaders($container, $config['cache']);
$this->loadProfileFilters($container, $config['filters']);
$this->loadSyntaxController($container);
$this->loadFilterController($container);
$this->loadSuiteWithPathsSetup($container);
$this->loadFilesystemFeatureLocator($container);
$this->loadFilesystemScenariosListLocator($container);
$this->loadFilesystemRerunScenariosListLocator($container);
}




public function process(ContainerBuilder $container)
{
$this->processLoaders($container);
}






private function loadParameters(ContainerBuilder $container)
{
$container->setParameter('gherkin.paths.lib', $this->getLibPath());
$container->setParameter('gherkin.paths.i18n', '%gherkin.paths.lib%/i18n.php');
$container->setParameter(
'suite.generic.default_settings',
array(
'paths' => array('%paths.base%/features'),
'contexts' => array('FeatureContext')
)
);
}






private function getLibPath()
{
$reflection = new ReflectionClass('Behat\Gherkin\Gherkin');
$libPath = rtrim(dirname($reflection->getFilename()) . '/../../../', DIRECTORY_SEPARATOR);

return $libPath;
}






private function loadGherkin(ContainerBuilder $container)
{
$definition = new Definition('Behat\Gherkin\Gherkin');
$container->setDefinition(self::MANAGER_ID, $definition);
}






private function loadKeywords(ContainerBuilder $container)
{
$definition = new Definition('Behat\Gherkin\Keywords\CachedArrayKeywords', array(
'%gherkin.paths.i18n%'
));
$container->setDefinition(self::KEYWORDS_ID, $definition);

$definition = new Definition('Behat\Gherkin\Keywords\KeywordsDumper', array(
new Reference(self::KEYWORDS_ID)
));
$container->setDefinition(self::KEYWORDS_DUMPER_ID, $definition);
}






private function loadParser(ContainerBuilder $container)
{
$definition = new Definition('Behat\Gherkin\Parser', array(
new Reference('gherkin.lexer')
));
$container->setDefinition('gherkin.parser', $definition);

$definition = new Definition('Behat\Gherkin\Lexer', array(
new Reference('gherkin.keywords')
));
$container->setDefinition('gherkin.lexer', $definition);
}







private function loadDefaultLoaders(ContainerBuilder $container, $cachePath)
{
$definition = new Definition('Behat\Gherkin\Loader\GherkinFileLoader', array(
new Reference('gherkin.parser')
));

if ($cachePath) {
$cacheDefinition = new Definition('Behat\Gherkin\Cache\FileCache', array($cachePath));
} else {
$cacheDefinition = new Definition('Behat\Gherkin\Cache\MemoryCache');
}

$definition->addMethodCall('setCache', array($cacheDefinition));
$definition->addTag(self::LOADER_TAG, array('priority' => 50));
$container->setDefinition('gherkin.loader.gherkin_file', $definition);
}







private function loadProfileFilters(ContainerBuilder $container, array $filters)
{
$gherkin = $container->getDefinition(self::MANAGER_ID);
foreach ($filters as $type => $filterString) {
$filter = $this->createFilterDefinition($type, $filterString);
$gherkin->addMethodCall('addFilter', array($filter));
}
}






private function loadSyntaxController(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Gherkin\Cli\SyntaxController', array(
new Reference(self::KEYWORDS_DUMPER_ID),
new Reference(TranslatorExtension::TRANSLATOR_ID)
));
$definition->addTag(CliExtension::CONTROLLER_TAG, array('priority' => 600));
$container->setDefinition(CliExtension::CONTROLLER_TAG . '.gherkin_syntax', $definition);
}






private function loadFilterController(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Gherkin\Cli\FilterController', array(
new Reference(self::MANAGER_ID)
));
$definition->addTag(CliExtension::CONTROLLER_TAG, array('priority' => 700));
$container->setDefinition(CliExtension::CONTROLLER_TAG . '.gherkin_filters', $definition);
}






private function loadSuiteWithPathsSetup(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Gherkin\Suite\Setup\SuiteWithPathsSetup', array(
'%paths.base%',
new Reference(FilesystemExtension::LOGGER_ID)
));
$definition->addTag(SuiteExtension::SETUP_TAG, array('priority' => 50));
$container->setDefinition(SuiteExtension::SETUP_TAG . '.suite_with_paths', $definition);
}






private function loadFilesystemFeatureLocator(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Gherkin\Specification\Locator\FilesystemFeatureLocator', array(
new Reference(self::MANAGER_ID),
'%paths.base%'
));
$definition->addTag(SpecificationExtension::LOCATOR_TAG, array('priority' => 60));
$container->setDefinition(SpecificationExtension::LOCATOR_TAG . '.filesystem_feature', $definition);
}






private function loadFilesystemScenariosListLocator(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Gherkin\Specification\Locator\FilesystemScenariosListLocator', array(
new Reference(self::MANAGER_ID)
));
$definition->addTag(SpecificationExtension::LOCATOR_TAG, array('priority' => 50));
$container->setDefinition(SpecificationExtension::LOCATOR_TAG . '.filesystem_scenarios_list', $definition);
}






private function loadFilesystemRerunScenariosListLocator(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Gherkin\Specification\Locator\FilesystemRerunScenariosListLocator', array(
new Reference(self::MANAGER_ID)
));
$definition->addTag(SpecificationExtension::LOCATOR_TAG, array('priority' => 50));
$container->setDefinition(SpecificationExtension::LOCATOR_TAG . '.filesystem_rerun_scenarios_list', $definition);
}






private function processLoaders(ContainerBuilder $container)
{
$references = $this->processor->findAndSortTaggedServices($container, self::LOADER_TAG);
$definition = $container->getDefinition(self::MANAGER_ID);

foreach ($references as $reference) {
$definition->addMethodCall('addLoader', array($reference));
}
}











private function createFilterDefinition($type, $filterString)
{
if ('role' === $type) {
return new Definition('Behat\Gherkin\Filter\RoleFilter', array($filterString));
}

if ('name' === $type) {
return new Definition('Behat\Gherkin\Filter\NameFilter', array($filterString));
}

if ('tags' === $type) {
return new Definition('Behat\Gherkin\Filter\TagFilter', array($filterString));
}

if ('narrative' === $type) {
return new Definition('Behat\Gherkin\Filter\NarrativeFilter', array($filterString));
}

throw new ExtensionException(sprintf(
'`%s` filter is not supported by the `filters` option of gherkin extension. Supported types are `%s`.',
$type,
implode('`, `', array('narrative', 'role', 'name', 'tags'))
), 'gherkin');
}
}
<?php









namespace Behat\Behat\Gherkin\Specification;

use Behat\Gherkin\Filter\FilterInterface;
use Behat\Gherkin\Filter\NameFilter;
use Behat\Gherkin\Filter\NarrativeFilter;
use Behat\Gherkin\Filter\RoleFilter;
use Behat\Gherkin\Filter\TagFilter;
use Behat\Gherkin\Gherkin;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Specification\SpecificationIterator;
use Behat\Testwork\Suite\Exception\SuiteConfigurationException;
use Behat\Testwork\Suite\Suite;






final class LazyFeatureIterator implements SpecificationIterator
{



private $suite;



private $gherkin;



private $paths = array();



private $filters = array();



private $position = 0;



private $features = array();



private $currentFeature;









public function __construct(Suite $suite, Gherkin $gherkin, array $paths, array $filters = array())
{
$this->suite = $suite;
$this->gherkin = $gherkin;
$this->paths = array_values($paths);
$this->filters = array_merge($this->getSuiteFilters($suite), $filters);
}




public function getSuite()
{
return $this->suite;
}




public function rewind()
{
$this->position = 0;
$this->moveToNextAvailableFeature();
}




public function next()
{
$this->moveToNextAvailableFeature();
}




public function valid()
{
return null !== $this->currentFeature;
}




public function key()
{
return $this->position;
}




public function current()
{
return $this->currentFeature;
}








private function getSuiteFilters(Suite $suite)
{
if (!$suite->hasSetting('filters') || !is_array($suite->getSetting('filters'))) {
return array();
}

$filters = array();
foreach ($suite->getSetting('filters') as $type => $filterString) {
$filters[] = $this->createFilter($type, $filterString, $suite);
}

return $filters;
}












private function createFilter($type, $filterString, Suite $suite)
{
if ('role' === $type) {
return new RoleFilter($filterString);
}

if ('name' === $type) {
return new NameFilter($filterString);
}

if ('tags' === $type) {
return new TagFilter($filterString);
}

if ('narrative' === $type) {
return new NarrativeFilter($filterString);
}

throw new SuiteConfigurationException(sprintf(
'`%s` filter is not supported by the `%s` suite. Supported types are `%s`.',
$type,
$suite->getName(),
implode('`, `', array('role', 'name', 'tags'))
), $suite->getName());
}




private function moveToNextAvailableFeature()
{
while (!count($this->features) && $this->position < count($this->paths)) {
$this->features = $this->parseFeature($this->paths[$this->position]);
$this->position++;
}

$this->currentFeature = array_shift($this->features);
}








private function parseFeature($path)
{
return $this->gherkin->load($path, $this->filters);
}
}
<?php









namespace Behat\Behat\Gherkin\Specification\Locator;

use Behat\Behat\Gherkin\Specification\LazyFeatureIterator;
use Behat\Gherkin\Filter\PathsFilter;
use Behat\Gherkin\Gherkin;
use Behat\Testwork\Specification\Locator\SpecificationLocator;
use Behat\Testwork\Specification\NoSpecificationsIterator;
use Behat\Testwork\Suite\Exception\SuiteConfigurationException;
use Behat\Testwork\Suite\Suite;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use RegexIterator;






final class FilesystemFeatureLocator implements SpecificationLocator
{



private $gherkin;



private $basePath;







public function __construct(Gherkin $gherkin, $basePath)
{
$this->gherkin = $gherkin;
$this->basePath = $basePath;
}




public function getLocatorExamples()
{
return array(
"a dir <comment>(features/)</comment>",
"a feature <comment>(*.feature)</comment>",
"a scenario at specific line <comment>(*.feature:10)</comment>.",
"all scenarios at or after a specific line <comment>(*.feature:10-*)</comment>.",
"all scenarios at a line within a specific range <comment>(*.feature:10-20)</comment>."
);
}




public function locateSpecifications(Suite $suite, $locator)
{
if (!$suite->hasSetting('paths')) {
return new NoSpecificationsIterator($suite);
}

$suiteLocators = $this->getSuitePaths($suite);

if ($locator) {
$filters = array(new PathsFilter($suiteLocators));

return new LazyFeatureIterator($suite, $this->gherkin, $this->findFeatureFiles($locator), $filters);
}

$featurePaths = array();
foreach ($suiteLocators as $suiteLocator) {
$featurePaths = array_merge($featurePaths, $this->findFeatureFiles($suiteLocator));
}

return new LazyFeatureIterator($suite, $this->gherkin, $featurePaths);
}










private function getSuitePaths(Suite $suite)
{
if (!is_array($suite->getSetting('paths'))) {
throw new SuiteConfigurationException(
sprintf('`paths` setting of the "%s" suite is expected to be an array, %s given.',
$suite->getName(),
gettype($suite->getSetting('paths'))
),
$suite->getName()
);
}

return $suite->getSetting('paths');
}








private function findFeatureFiles($path)
{
$absolutePath = $this->findAbsolutePath($path);

if (!$absolutePath) {
return array($path);
}

if (is_file($absolutePath)) {
return array($absolutePath);
}

$iterator = new RegexIterator(
new RecursiveIteratorIterator(
new RecursiveDirectoryIterator(
$absolutePath,
RecursiveDirectoryIterator::FOLLOW_SYMLINKS | RecursiveDirectoryIterator::SKIP_DOTS
)
),
'/^.+\.feature$/i',
RegexIterator::MATCH
);

$paths = array_map('strval', iterator_to_array($iterator));
uasort($paths, 'strnatcasecmp');

return $paths;
}








private function findAbsolutePath($path)
{
if (is_file($path) || is_dir($path)) {
return realpath($path);
}

if (null === $this->basePath) {
return false;
}

if (is_file($this->basePath . DIRECTORY_SEPARATOR . $path)
|| is_dir($this->basePath . DIRECTORY_SEPARATOR . $path)
) {
return realpath($this->basePath . DIRECTORY_SEPARATOR . $path);
}

return false;
}
}
<?php









namespace Behat\Behat\Gherkin\Specification\Locator;

use Behat\Behat\Gherkin\Specification\LazyFeatureIterator;
use Behat\Gherkin\Gherkin;
use Behat\Testwork\Specification\Locator\SpecificationLocator;
use Behat\Testwork\Specification\NoSpecificationsIterator;
use Behat\Testwork\Suite\Suite;






final class FilesystemRerunScenariosListLocator implements SpecificationLocator
{



private $gherkin;






public function __construct(Gherkin $gherkin)
{
$this->gherkin = $gherkin;
}




public function getLocatorExamples()
{
return array();
}




public function locateSpecifications(Suite $suite, $locator)
{
if (!is_file($locator) || 'rerun' !== pathinfo($locator, PATHINFO_EXTENSION)) {
return new NoSpecificationsIterator($suite);
}

$scenarios = json_decode(trim(file_get_contents($locator)), true);
if (empty($scenarios) || empty($scenarios[$suite->getName()])) {
return new NoSpecificationsIterator($suite);
}

return new LazyFeatureIterator($suite, $this->gherkin, $scenarios[$suite->getName()]);
}
}
<?php









namespace Behat\Behat\Gherkin\Specification\Locator;

use Behat\Behat\Gherkin\Specification\LazyFeatureIterator;
use Behat\Gherkin\Gherkin;
use Behat\Testwork\Specification\Locator\SpecificationLocator;
use Behat\Testwork\Specification\NoSpecificationsIterator;
use Behat\Testwork\Suite\Suite;






final class FilesystemScenariosListLocator implements SpecificationLocator
{



private $gherkin;






public function __construct(Gherkin $gherkin)
{
$this->gherkin = $gherkin;
}




public function getLocatorExamples()
{
return array("a scenarios list file <comment>(*.scenarios)</comment>.");
}




public function locateSpecifications(Suite $suite, $locator)
{
if (!is_file($locator) || 'scenarios' !== pathinfo($locator, PATHINFO_EXTENSION)) {
return new NoSpecificationsIterator($suite);
}

$scenarios = explode("\n", trim(file_get_contents($locator)));

return new LazyFeatureIterator($suite, $this->gherkin, $scenarios);
}
}
<?php









namespace Behat\Behat\Gherkin\Suite\Setup;

use Behat\Testwork\Filesystem\FilesystemLogger;
use Behat\Testwork\Suite\Setup\SuiteSetup;
use Behat\Testwork\Suite\Suite;






final class SuiteWithPathsSetup implements SuiteSetup
{



private $basePath;



private $logger;







public function __construct($basePath, FilesystemLogger $logger = null)
{
$this->basePath = $basePath;
$this->logger = $logger;
}




public function supportsSuite(Suite $suite)
{
return $suite->hasSetting('paths') && is_array($suite->getSetting('paths'));
}




public function setupSuite(Suite $suite)
{
foreach ($suite->getSetting('paths') as $locator) {
if (0 !== strpos($locator, '@') && !is_dir($path = $this->locatePath($locator))) {
$this->createFeatureDirectory($path);
}
}
}






private function createFeatureDirectory($path)
{
mkdir($path, 0777, true);

if ($this->logger) {
$this->logger->directoryCreated($path, 'place your *.feature files here');
}
}








private function locatePath($path)
{
if ($this->isAbsolutePath($path)) {
return $path;
}

return $this->basePath . DIRECTORY_SEPARATOR . $path;
}








private function isAbsolutePath($file)
{
if ($file[0] == '/' || $file[0] == '\\'
|| (strlen($file) > 3 && ctype_alpha($file[0])
&& $file[1] == ':'
&& ($file[2] == '\\' || $file[2] == '/')
)
|| null !== parse_url($file, PHP_URL_SCHEME)
) {
return true;
}

return false;
}
}
<?php









namespace Behat\Behat\HelperContainer\Argument;

use Behat\Behat\Context\Argument\ArgumentResolver;
use Interop\Container\ContainerInterface;
use ReflectionClass;








final class ServicesResolver implements ArgumentResolver
{



private $container;






public function __construct(ContainerInterface $container)
{
$this->container = $container;
}




public function resolveArguments(ReflectionClass $classReflection, array $arguments)
{
return array_map(array($this, 'resolveArgument'), $arguments);
}











private function resolveArgument($value)
{
if ('@' === mb_substr($value, 0, 1)) {
return $this->container->get(mb_substr($value, 1));
}

return $value;
}
}
<?php









namespace Behat\Behat\HelperContainer\Argument;

use Behat\Behat\Context\Argument\SuiteScopedResolverFactory;
use Behat\Behat\HelperContainer\BuiltInServiceContainer;
use Behat\Behat\HelperContainer\Exception\WrongContainerClassException;
use Behat\Behat\HelperContainer\Exception\WrongServicesConfigurationException;
use Behat\Behat\HelperContainer\ServiceContainer\HelperContainerExtension;
use Behat\Testwork\Suite\Suite;
use Interop\Container\ContainerInterface;
use Symfony\Component\DependencyInjection\TaggedContainerInterface;








final class ServicesResolverFactory implements SuiteScopedResolverFactory
{



private $container;






public function __construct(TaggedContainerInterface $container)
{
$this->container = $container;
}




public function generateArgumentResolvers(Suite $suite)
{
if (!$suite->hasSetting('services')) {
return array();
}

$container = $this->createContainer($suite->getSetting('services'));

return array($this->createArgumentResolver($container));
}








private function createContainer($settings)
{
if (is_string($settings)) {
return $this->createContainerFromString($settings);
}

if (is_array($settings)) {
return $this->createContainerFromArray($settings);
}

throw new WrongServicesConfigurationException(
sprintf('`services` must be either string or an array, but `%s` given.', gettype($settings))
);
}








private function createContainerFromString($settings)
{
if ('@' === mb_substr($settings, 0, 1)) {
return $this->loadContainerFromContainer(mb_substr($settings, 1));
}

return $this->createContainerFromClassSpec($settings);
}








private function createContainerFromArray(array $settings)
{
return new BuiltInServiceContainer($settings);
}








private function loadContainerFromContainer($name)
{
$services = $this->container->findTaggedServiceIds(HelperContainerExtension::HELPER_CONTAINER_TAG);

if (!in_array($name, array_keys($services))) {
throw new WrongServicesConfigurationException(
sprintf('Service container `@%s` was not found.', $name)
);
}

return $this->container->get($name);
}








private function createContainerFromClassSpec($classSpec)
{
$constructor = explode('::', $classSpec);

if (2 == count($constructor)) {
return call_user_func($constructor);
}

return new $constructor[0];
}








private function createArgumentResolver($container)
{
if (!$container instanceof ContainerInterface) {
throw new WrongContainerClassException(
sprintf(
'Service container is expected to implement `Interop\Container\ContainerInterface`, but `%s` does not.',
get_class($container)
),
get_class($container)
);
}

return new ServicesResolver($container);
}
}
<?php









namespace Behat\Behat\HelperContainer;

use Behat\Behat\HelperContainer\Exception\ServiceNotFoundException;
use Behat\Behat\HelperContainer\Exception\WrongServicesConfigurationException;
use Interop\Container\ContainerInterface;
use ReflectionClass;
use ReflectionMethod;






final class BuiltInServiceContainer implements ContainerInterface
{



private $schema;



private $instances;






public function __construct(array $schema)
{
$this->schema = $schema;
}




public function has($id)
{
return isset($this->schema[$id]);
}




public function get($id)
{
if (!$this->has($id)) {
throw new ServiceNotFoundException(
sprintf('Service with id `%s` was not defined inside the `services` setting`.', $id),
$id
);
}

return $this->instances[$id] = isset($this->instances[$id]) ? $this->instances[$id] : $this->createInstance($id);
}








private function createInstance($id)
{
$schema = $this->getAndValidateServiceSchema($id);

$reflection = new ReflectionClass($schema['class']);
$arguments = $schema['arguments'];

if ($factoryMethod = $this->getAndValidateFactoryMethod($reflection, $schema)) {
return $factoryMethod->invokeArgs(null, $arguments);
}

return $reflection->newInstanceArgs($arguments);
}










private function getAndValidateServiceSchema($id)
{
$schema = $this->schema[$id];

if (is_string($schema)) {
$schema = array('class' => $schema);
}

$schema['class'] = $this->getAndValidateClass($id, $schema);
$schema['arguments'] = $this->getAndValidateArguments($schema);

return $schema;
}









private function getAndValidateClass($id, array $schema)
{
if (!isset($schema['class'])) {
throw new WrongServicesConfigurationException(sprintf(
'All services of the built-in `services` must have `class` option set, but `%s` does not.',
$id
));
}

return $schema['class'];
}








private function getAndValidateArguments(array $schema)
{
return isset($schema['arguments']) ? (array)$schema['arguments'] : array();
}









private function getAndValidateFactoryMethod(ReflectionClass $reflection, array $schema)
{
if (!isset($schema['factory_method'])) {
return null;
}

$factoryMethod = $schema['factory_method'];
$this->assertFactoryMethodExists($reflection, $factoryMethod);
$method = $reflection->getMethod($factoryMethod);
$this->assertFactoryMethodIsStatic($method);

return $method;
}









private function assertFactoryMethodExists(ReflectionClass $class, $methodName)
{
if (!$class->hasMethod($methodName)) {
throw new WrongServicesConfigurationException(sprintf(
'Factory method `%s::%s` does not exist.',
$class->getName(),
$methodName
));
}
}








private function assertFactoryMethodIsStatic(ReflectionMethod $method)
{
if (!$method->isStatic()) {
throw new WrongServicesConfigurationException(sprintf(
'Service factory methods must be static, but `%s::%s` is not.',
$method->getDeclaringClass()->getName(),
$method->getName()
));
}
}
}
<?php









namespace Behat\Behat\HelperContainer\Exception;

use Behat\Testwork\Environment\Exception\EnvironmentException;
use Interop\Container\Exception\ContainerException;






interface HelperContainerException extends ContainerException, EnvironmentException
{
}
<?php









namespace Behat\Behat\HelperContainer\Exception;

use Interop\Container\Exception\NotFoundException;
use InvalidArgumentException;






final class ServiceNotFoundException extends InvalidArgumentException implements HelperContainerException, NotFoundException
{



private $serviceId;







public function __construct($message, $serviceId)
{
$this->serviceId = $serviceId;

parent::__construct($message);
}






public function getServiceId()
{
return $this->serviceId;
}
}
<?php









namespace Behat\Behat\HelperContainer\Exception;

use InvalidArgumentException;






final class WrongContainerClassException extends InvalidArgumentException implements HelperContainerException
{



private $class;







public function __construct($message, $class)
{
$this->class = $class;

parent::__construct($message);
}






public function getClass()
{
return $this->class;
}
}
<?php









namespace Behat\Behat\HelperContainer\Exception;

use RuntimeException;






final class WrongServicesConfigurationException extends RuntimeException implements HelperContainerException
{
}
<?php









namespace Behat\Behat\HelperContainer\ServiceContainer;

use Behat\Behat\Context\ServiceContainer\ContextExtension;
use Behat\Behat\HelperContainer\Exception\WrongServicesConfigurationException;
use Behat\Testwork\ServiceContainer\Extension;
use Behat\Testwork\ServiceContainer\ExtensionManager;
use Behat\Testwork\ServiceContainer\ServiceProcessor;
use Symfony\Component\Config\Definition\Builder\ArrayNodeDefinition;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Definition;








final class HelperContainerExtension implements Extension
{



const HELPER_CONTAINER_TAG = 'helper_container.container';




private $processor;






public function __construct(ServiceProcessor $processor = null)
{
$this->processor = $processor ? : new ServiceProcessor();
}




public function getConfigKey()
{
return 'helper_container';
}




public function initialize(ExtensionManager $extensionManager)
{
}




public function configure(ArrayNodeDefinition $builder)
{
}




public function load(ContainerBuilder $container, array $config)
{
$definition = new Definition('Behat\Behat\HelperContainer\Argument\ServicesResolverFactory', array($container));
$definition->addTag(ContextExtension::SUITE_SCOPED_RESOLVER_FACTORY_TAG, array('priority' => 0));
$container->setDefinition(ContextExtension::SUITE_SCOPED_RESOLVER_FACTORY_TAG . '.helper_container', $definition);
}




public function process(ContainerBuilder $container)
{
$references = $this->processor->findAndSortTaggedServices($container, self::HELPER_CONTAINER_TAG);

foreach ($references as $reference) {
if ($this->isDefinitionShared($container->getDefinition((string) $reference))) {
throw new WrongServicesConfigurationException(sprintf(
'Container services must not be configured as shared, but `@%s` is.', $reference
));
}
}
}










private function isDefinitionShared(Definition $definition)
{
if (method_exists($definition, 'isShared')) {
return $definition->isShared();
} else if (method_exists($definition, 'getScope')) {
return $definition->getScope() !== ContainerBuilder::SCOPE_PROTOTYPE;
}

return false;
}
}
<?php









namespace Behat\Behat\Hook\Call;

use Behat\Behat\Hook\Scope\FeatureScope;






final class AfterFeature extends RuntimeFeatureHook
{







public function __construct($filterString, $callable, $description = null)
{
parent::__construct(FeatureScope::AFTER, $filterString, $callable, $description);
}




public function getName()
{
return 'AfterFeature';
}
}
<?php









namespace Behat\Behat\Hook\Call;

use Behat\Behat\Hook\Scope\ScenarioScope;






final class AfterScenario extends RuntimeScenarioHook
{







public function __construct($filterString, $callable, $description = null)
{
parent::__construct(ScenarioScope::AFTER, $filterString, $callable, $description);
}




public function getName()
{
return 'AfterScenario';
}
}
<?php









namespace Behat\Behat\Hook\Call;

use Behat\Behat\Hook\Scope\StepScope;






final class AfterStep extends RuntimeStepHook
{







public function __construct($filterString, $callable, $description = null)
{
parent::__construct(StepScope::AFTER, $filterString, $callable, $description);
}




public function getName()
{
return 'AfterStep';
}
}
<?php









namespace Behat\Behat\Hook\Call;

use Behat\Behat\Hook\Scope\FeatureScope;






final class BeforeFeature extends RuntimeFeatureHook
{







public function __construct($filterString, $callable, $description = null)
{
parent::__construct(FeatureScope::BEFORE, $filterString, $callable, $description);
}




public function getName()
{
return 'BeforeFeature';
}
}
<?php









namespace Behat\Behat\Hook\Call;

use Behat\Behat\Hook\Scope\ScenarioScope;






final class BeforeScenario extends RuntimeScenarioHook
{







public function __construct($filterString, $callable, $description = null)
{
parent::__construct(ScenarioScope::BEFORE, $filterString, $callable, $description);
}




public function getName()
{
return 'BeforeScenario';
}
}
<?php









namespace Behat\Behat\Hook\Call;

use Behat\Behat\Hook\Scope\StepScope;






final class BeforeStep extends RuntimeStepHook
{







public function __construct($filterString, $callable, $description = null)
{
parent::__construct(StepScope::BEFORE, $filterString, $callable, $description);
}




public function getName()
{
return 'BeforeStep';
}
}
<?php









namespace Behat\Behat\Hook\Call;

use Behat\Behat\Hook\Scope\FeatureScope;
use Behat\Gherkin\Filter\NameFilter;
use Behat\Gherkin\Filter\TagFilter;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Call\Exception\BadCallbackException;
use Behat\Testwork\Hook\Call\RuntimeFilterableHook;
use Behat\Testwork\Hook\Scope\HookScope;






abstract class RuntimeFeatureHook extends RuntimeFilterableHook
{










public function __construct($scopeName, $filterString, $callable, $description = null)
{
parent::__construct($scopeName, $filterString, $callable, $description);

if ($this->isAnInstanceMethod()) {
throw new BadCallbackException(sprintf(
'Feature hook callback: %s::%s() must be a static method',
$callable[0],
$callable[1]
), $callable);
}
}




public function filterMatches(HookScope $scope)
{
if (!$scope instanceof FeatureScope) {
return false;
}

if (null === ($filterString = $this->getFilterString())) {
return true;
}

return $this->isMatch($scope->getFeature(), $filterString);
}







private function isMatch(FeatureNode $feature, $filterString)
{
if (false !== strpos($filterString, '@')) {
return $this->isMatchTagFilter($feature, $filterString);
}

if (!empty($filterString)) {
return $this->isMatchNameFilter($feature, $filterString);
}

return false;
}









private function isMatchTagFilter(FeatureNode $feature, $filterString)
{
$filter = new TagFilter($filterString);

return $filter->isFeatureMatch($feature);
}









private function isMatchNameFilter(FeatureNode $feature, $filterString)
{
$filter = new NameFilter($filterString);

return $filter->isFeatureMatch($feature);
}
}
<?php









namespace Behat\Behat\Hook\Call;

use Behat\Behat\Hook\Scope\ScenarioScope;
use Behat\Gherkin\Filter\NameFilter;
use Behat\Gherkin\Filter\TagFilter;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface;
use Behat\Testwork\Hook\Call\RuntimeFilterableHook;
use Behat\Testwork\Hook\Scope\HookScope;






abstract class RuntimeScenarioHook extends RuntimeFilterableHook
{



public function filterMatches(HookScope $scope)
{
if (!$scope instanceof ScenarioScope) {
return false;
}

if (null === ($filterString = $this->getFilterString())) {
return true;
}

return $this->isMatch($scope->getFeature(), $scope->getScenario(), $filterString);
}










protected function isMatch(FeatureNode $feature, ScenarioInterface $scenario, $filterString)
{
if (false !== strpos($filterString, '@')) {
return $this->isMatchTagFilter($feature, $scenario, $filterString);
}

if (!empty($filterString)) {
return $this->isMatchNameFilter($scenario, $filterString);
}

return false;
}










protected function isMatchTagFilter(FeatureNode $feature, ScenarioInterface $scenario, $filterString)
{
$filter = new TagFilter($filterString);

if ($filter->isFeatureMatch($feature)) {
return true;
}

return $filter->isScenarioMatch($feature, $scenario);
}









protected function isMatchNameFilter(ScenarioInterface $scenario, $filterString)
{
$filter = new NameFilter($filterString);

return $filter->isScenarioMatch($scenario);
}
}
<?php









namespace Behat\Behat\Hook\Call;

use Behat\Behat\Hook\Scope\StepScope;
use Behat\Gherkin\Filter\NameFilter;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Hook\Call\RuntimeFilterableHook;
use Behat\Testwork\Hook\Scope\HookScope;






abstract class RuntimeStepHook extends RuntimeFilterableHook
{



public function filterMatches(HookScope $scope)
{
if (!$scope instanceof StepScope) {
return false;
}

if (null === ($filterString = $this->getFilterString())) {
return true;
}

if (!empty($filterString)) {
$filter = new NameFilter($filterString);

if ($filter->isFeatureMatch($scope->getFeature())) {
return true;
}

return $this->isStepMatch($scope->getStep(), $filterString);
}

return false;
}









private function isStepMatch(StepNode $step, $filterString)
{
if ('/' === $filterString[0]) {
return 1 === preg_match($filterString, $step->getText());
}

return false !== mb_strpos($step->getText(), $filterString, 0, 'utf8');
}
}
<?php









namespace Behat\Behat\Hook\Context\Annotation;

use Behat\Behat\Context\Annotation\AnnotationReader;
use Behat\Testwork\Hook\Call\RuntimeHook;
use ReflectionMethod;






final class HookAnnotationReader implements AnnotationReader
{



private static $regex = '/^\@(beforesuite|aftersuite|beforefeature|afterfeature|beforescenario|afterscenario|beforestep|afterstep)(?:\s+(.+))?$/i';



private static $classes = array(
'beforesuite' => 'Behat\Testwork\Hook\Call\BeforeSuite',
'aftersuite' => 'Behat\Testwork\Hook\Call\AfterSuite',
'beforefeature' => 'Behat\Behat\Hook\Call\BeforeFeature',
'afterfeature' => 'Behat\Behat\Hook\Call\AfterFeature',
'beforescenario' => 'Behat\Behat\Hook\Call\BeforeScenario',
'afterscenario' => 'Behat\Behat\Hook\Call\AfterScenario',
'beforestep' => 'Behat\Behat\Hook\Call\BeforeStep',
'afterstep' => 'Behat\Behat\Hook\Call\AfterStep'
);











public function readCallee($contextClass, ReflectionMethod $method, $docLine, $description)
{
if (!preg_match(self::$regex, $docLine, $match)) {
return null;
}

$type = strtolower($match[1]);
$class = self::$classes[$type];
$pattern = isset($match[2]) ? $match[2] : null;
$callable = array($contextClass, $method->getName());

return new $class($pattern, $callable, $description);
}
}
<?php









namespace Behat\Behat\Hook\Scope;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Hook\Scope\AfterTestScope;
use Behat\Testwork\Suite\Suite;
use Behat\Testwork\Tester\Result\TestResult;






final class AfterFeatureScope implements FeatureScope, AfterTestScope
{



private $environment;



private $feature;



private $result;








public function __construct(Environment $env, FeatureNode $feature, TestResult $result)
{
$this->environment = $env;
$this->feature = $feature;
$this->result = $result;
}






public function getName()
{
return self::AFTER;
}






public function getSuite()
{
return $this->environment->getSuite();
}






public function getEnvironment()
{
return $this->environment;
}






public function getFeature()
{
return $this->feature;
}






public function getTestResult()
{
return $this->result;
}
}
<?php









namespace Behat\Behat\Hook\Scope;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface as Scenario;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Hook\Scope\AfterTestScope;
use Behat\Testwork\Suite\Suite;
use Behat\Testwork\Tester\Result\TestResult;






final class AfterScenarioScope implements ScenarioScope, AfterTestScope
{



private $environment;



private $feature;



private $scenario;



private $result;









public function __construct(Environment $env, FeatureNode $feature, Scenario $scenario, TestResult $result)
{
$this->environment = $env;
$this->feature = $feature;
$this->scenario = $scenario;
$this->result = $result;
}






public function getName()
{
return self::AFTER;
}






public function getSuite()
{
return $this->environment->getSuite();
}






public function getEnvironment()
{
return $this->environment;
}






public function getFeature()
{
return $this->feature;
}






public function getScenario()
{
return $this->scenario;
}






public function getTestResult()
{
return $this->result;
}
}
<?php









namespace Behat\Behat\Hook\Scope;

use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Hook\Scope\AfterTestScope;
use Behat\Testwork\Suite\Suite;
use Behat\Testwork\Tester\Result\TestResult;






final class AfterStepScope implements StepScope, AfterTestScope
{



private $environment;



private $feature;



private $step;



private $result;









public function __construct(Environment $env, FeatureNode $feature, StepNode $step, StepResult $result)
{
$this->environment = $env;
$this->feature = $feature;
$this->step = $step;
$this->result = $result;
}






public function getName()
{
return self::AFTER;
}






public function getSuite()
{
return $this->environment->getSuite();
}






public function getEnvironment()
{
return $this->environment;
}






public function getFeature()
{
return $this->feature;
}






public function getStep()
{
return $this->step;
}






public function getTestResult()
{
return $this->result;
}
}
<?php









namespace Behat\Behat\Hook\Scope;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Suite\Suite;






final class BeforeFeatureScope implements FeatureScope
{



private $environment;



private $feature;







public function __construct(Environment $env, FeatureNode $feature)
{
$this->environment = $env;
$this->feature = $feature;
}






public function getName()
{
return self::BEFORE;
}






public function getSuite()
{
return $this->environment->getSuite();
}






public function getEnvironment()
{
return $this->environment;
}






public function getFeature()
{
return $this->feature;
}
}
<?php









namespace Behat\Behat\Hook\Scope;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface as Scenario;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Suite\Suite;






final class BeforeScenarioScope implements ScenarioScope
{



private $environment;



private $feature;



private $scenario;








public function __construct(Environment $env, FeatureNode $feature, Scenario $scenario)
{
$this->environment = $env;
$this->feature = $feature;
$this->scenario = $scenario;
}






public function getName()
{
return self::BEFORE;
}






public function getSuite()
{
return $this->environment->getSuite();
}






public function getEnvironment()
{
return $this->environment;
}






public function getFeature()
{
return $this->feature;
}






public function getScenario()
{
return $this->scenario;
}
}
<?php









namespace Behat\Behat\Hook\Scope;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Suite\Suite;






final class BeforeStepScope implements StepScope
{



private $environment;



private $feature;



private $step;








public function __construct(Environment $env, FeatureNode $feature, StepNode $step)
{
$this->environment = $env;
$this->feature = $feature;
$this->step = $step;
}






public function getName()
{
return self::BEFORE;
}






public function getSuite()
{
return $this->environment->getSuite();
}






public function getEnvironment()
{
return $this->environment;
}






public function getFeature()
{
return $this->feature;
}






public function getStep()
{
return $this->step;
}
}
<?php









namespace Behat\Behat\Hook\Scope;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Hook\Scope\HookScope;






interface FeatureScope extends HookScope
{
const BEFORE = 'feature.before';
const AFTER = 'feature.after';






public function getFeature();
}
<?php









namespace Behat\Behat\Hook\Scope;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface as Scenario;
use Behat\Testwork\Hook\Scope\HookScope;






interface ScenarioScope extends HookScope
{
const BEFORE = 'scenario.before';
const AFTER = 'scenario.after';






public function getFeature();






public function getScenario();
}
<?php









namespace Behat\Behat\Hook\Scope;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Hook\Scope\HookScope;






interface StepScope extends HookScope
{
const BEFORE = 'step.before';
const AFTER = 'step.after';






public function getFeature();






public function getStep();
}
<?php









namespace Behat\Behat\Hook\ServiceContainer;

use Behat\Behat\Context\ServiceContainer\ContextExtension;
use Behat\Behat\Tester\ServiceContainer\TesterExtension;
use Behat\Testwork\Hook\ServiceContainer\HookExtension as BaseExtension;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Definition;
use Symfony\Component\DependencyInjection\Reference;






final class HookExtension extends BaseExtension
{



public function load(ContainerBuilder $container, array $config)
{
parent::load($container, $config);

$this->loadAnnotationReader($container);
}






protected function loadHookableTesters(ContainerBuilder $container)
{
parent::loadHookableTesters($container);

$definition = new Definition('Behat\Behat\Hook\Tester\HookableFeatureTester', array(
new Reference(TesterExtension::SPECIFICATION_TESTER_ID),
new Reference(self::DISPATCHER_ID)
));
$definition->addTag(TesterExtension::SPECIFICATION_TESTER_WRAPPER_TAG, array('priority' => 9999));
$container->setDefinition(TesterExtension::SPECIFICATION_TESTER_WRAPPER_TAG . '.hookable', $definition);

$definition = new Definition('Behat\Behat\Hook\Tester\HookableScenarioTester', array(
new Reference(TesterExtension::SCENARIO_TESTER_ID),
new Reference(self::DISPATCHER_ID)
)
);
$definition->addTag(TesterExtension::SCENARIO_TESTER_WRAPPER_TAG, array('priority' => 9999));
$container->setDefinition(TesterExtension::SCENARIO_TESTER_WRAPPER_TAG . '.hookable', $definition);

$definition = new Definition('Behat\Behat\Hook\Tester\HookableScenarioTester', array(
new Reference(TesterExtension::EXAMPLE_TESTER_ID),
new Reference(self::DISPATCHER_ID)
)
);
$definition->addTag(TesterExtension::EXAMPLE_TESTER_WRAPPER_TAG, array('priority' => 9999));
$container->setDefinition(TesterExtension::EXAMPLE_TESTER_WRAPPER_TAG . '.hookable', $definition);

$definition = new Definition('Behat\Behat\Hook\Tester\HookableStepTester', array(
new Reference(TesterExtension::STEP_TESTER_ID),
new Reference(self::DISPATCHER_ID)
));
$definition->addTag(TesterExtension::STEP_TESTER_WRAPPER_TAG, array('priority' => 9999));
$container->setDefinition(TesterExtension::STEP_TESTER_WRAPPER_TAG . '.hookable', $definition);
}






private function loadAnnotationReader(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Hook\Context\Annotation\HookAnnotationReader');
$definition->addTag(ContextExtension::ANNOTATION_READER_TAG, array('priority' => 50));
$container->setDefinition(ContextExtension::ANNOTATION_READER_TAG . '.hook', $definition);
}
}
<?php









namespace Behat\Behat\Hook\Tester;

use Behat\Behat\Hook\Scope\AfterFeatureScope;
use Behat\Behat\Hook\Scope\BeforeFeatureScope;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Hook\HookDispatcher;
use Behat\Testwork\Hook\Tester\Setup\HookedSetup;
use Behat\Testwork\Hook\Tester\Setup\HookedTeardown;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\SpecificationTester;






final class HookableFeatureTester implements SpecificationTester
{



private $baseTester;



private $hookDispatcher;







public function __construct(SpecificationTester $baseTester, HookDispatcher $hookDispatcher)
{
$this->baseTester = $baseTester;
$this->hookDispatcher = $hookDispatcher;
}




public function setUp(Environment $env, $spec, $skip)
{
$setup = $this->baseTester->setUp($env, $spec, $skip);

if ($skip) {
return $setup;
}

$scope = new BeforeFeatureScope($env, $spec);
$hookCallResults = $this->hookDispatcher->dispatchScopeHooks($scope);

return new HookedSetup($setup, $hookCallResults);
}




public function test(Environment $env, $spec, $skip)
{
return $this->baseTester->test($env, $spec, $skip);
}




public function tearDown(Environment $env, $spec, $skip, TestResult $result)
{
$teardown = $this->baseTester->tearDown($env, $spec, $skip, $result);

if ($skip) {
return $teardown;
}

$scope = new AfterFeatureScope($env, $spec, $result);
$hookCallResults = $this->hookDispatcher->dispatchScopeHooks($scope);

return new HookedTeardown($teardown, $hookCallResults);
}
}
<?php









namespace Behat\Behat\Hook\Tester;

use Behat\Behat\Hook\Scope\AfterScenarioScope;
use Behat\Behat\Hook\Scope\BeforeScenarioScope;
use Behat\Behat\Tester\ScenarioTester;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface as Scenario;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Hook\HookDispatcher;
use Behat\Testwork\Hook\Tester\Setup\HookedSetup;
use Behat\Testwork\Hook\Tester\Setup\HookedTeardown;
use Behat\Testwork\Tester\Result\TestResult;






final class HookableScenarioTester implements ScenarioTester
{



private $baseTester;



private $hookDispatcher;







public function __construct(ScenarioTester $baseTester, HookDispatcher $hookDispatcher)
{
$this->baseTester = $baseTester;
$this->hookDispatcher = $hookDispatcher;
}




public function setUp(Environment $env, FeatureNode $feature, Scenario $scenario, $skip)
{
$setup = $this->baseTester->setUp($env, $feature, $scenario, $skip);

if ($skip) {
return $setup;
}

$scope = new BeforeScenarioScope($env, $feature, $scenario);
$hookCallResults = $this->hookDispatcher->dispatchScopeHooks($scope);

return new HookedSetup($setup, $hookCallResults);
}




public function test(Environment $env, FeatureNode $feature, Scenario $scenario, $skip)
{
return $this->baseTester->test($env, $feature, $scenario, $skip);
}




public function tearDown(Environment $env, FeatureNode $feature, Scenario $scenario, $skip, TestResult $result)
{
$teardown = $this->baseTester->tearDown($env, $feature, $scenario, $skip, $result);

if ($skip) {
return $teardown;
}

$scope = new AfterScenarioScope($env, $feature, $scenario, $result);
$hookCallResults = $this->hookDispatcher->dispatchScopeHooks($scope);

return new HookedTeardown($teardown, $hookCallResults);
}
}
<?php









namespace Behat\Behat\Hook\Tester;

use Behat\Behat\Hook\Scope\AfterStepScope;
use Behat\Behat\Hook\Scope\BeforeStepScope;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Behat\Tester\StepTester;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Hook\HookDispatcher;
use Behat\Testwork\Hook\Tester\Setup\HookedSetup;
use Behat\Testwork\Hook\Tester\Setup\HookedTeardown;






final class HookableStepTester implements StepTester
{



private $baseTester;



private $hookDispatcher;







public function __construct(StepTester $baseTester, HookDispatcher $hookDispatcher)
{
$this->baseTester = $baseTester;
$this->hookDispatcher = $hookDispatcher;
}




public function setUp(Environment $env, FeatureNode $feature, StepNode $step, $skip)
{
$setup = $this->baseTester->setUp($env, $feature, $step, $skip);

if ($skip) {
return $setup;
}

$scope = new BeforeStepScope($env, $feature, $step);
$hookCallResults = $this->hookDispatcher->dispatchScopeHooks($scope);

return new HookedSetup($setup, $hookCallResults);
}




public function test(Environment $env, FeatureNode $feature, StepNode $step, $skip)
{
return $this->baseTester->test($env, $feature, $step, $skip);
}




public function tearDown(Environment $env, FeatureNode $feature, StepNode $step, $skip, StepResult $result)
{
$teardown = $this->baseTester->tearDown($env, $feature, $step, $skip, $result);

if ($skip) {
return $teardown;
}

$scope = new AfterStepScope($env, $feature, $step, $result);
$hookCallResults = $this->hookDispatcher->dispatchScopeHooks($scope);

return new HookedTeardown($teardown, $hookCallResults);
}
}
<?php









namespace Behat\Behat\Output\Exception;

use Behat\Testwork\Output\Exception\OutputException;
use InvalidArgumentException;






class NodeVisitorNotFoundException extends InvalidArgumentException implements OutputException
{
}
<?php









namespace Behat\Behat\Output\Node\EventListener\AST;

use Behat\Behat\EventDispatcher\Event\AfterFeatureSetup;
use Behat\Behat\EventDispatcher\Event\AfterFeatureTested;
use Behat\Behat\EventDispatcher\Event\FeatureTested;
use Behat\Behat\Output\Node\Printer\FeaturePrinter;
use Behat\Behat\Output\Node\Printer\SetupPrinter;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;






final class FeatureListener implements EventListener
{



private $featurePrinter;



private $setupPrinter;







public function __construct(FeaturePrinter $featurePrinter, SetupPrinter $setupPrinter)
{
$this->featurePrinter = $featurePrinter;
$this->setupPrinter = $setupPrinter;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
if (!$event instanceof FeatureTested) {
return;
}

$this->printHeaderOnBeforeEvent($formatter, $event);
$this->printFooterOnAfterEvent($formatter, $event);
}







private function printHeaderOnBeforeEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof AfterFeatureSetup) {
return;
}

$this->setupPrinter->printSetup($formatter, $event->getSetup());
$this->featurePrinter->printHeader($formatter, $event->getFeature());
}







private function printFooterOnAfterEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof AfterFeatureTested) {
return;
}

$this->setupPrinter->printTeardown($formatter, $event->getTeardown());
$this->featurePrinter->printFooter($formatter, $event->getTestResult());
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\AST;

use Behat\Behat\EventDispatcher\Event\AfterOutlineTested;
use Behat\Behat\EventDispatcher\Event\AfterScenarioSetup;
use Behat\Behat\EventDispatcher\Event\AfterScenarioTested;
use Behat\Behat\EventDispatcher\Event\AfterStepSetup;
use Behat\Behat\EventDispatcher\Event\AfterStepTested;
use Behat\Behat\EventDispatcher\Event\BeforeOutlineTested;
use Behat\Behat\EventDispatcher\Event\ExampleTested;
use Behat\Behat\Output\Node\Printer\ExamplePrinter;
use Behat\Behat\Output\Node\Printer\OutlinePrinter;
use Behat\Behat\Output\Node\Printer\SetupPrinter;
use Behat\Behat\Output\Node\Printer\StepPrinter;
use Behat\Gherkin\Node\ExampleNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;






final class OutlineListener implements EventListener
{



private $outlinePrinter;



private $examplePrinter;



private $stepPrinter;



private $stepSetupPrinter;



private $exampleSetupPrinter;



private $example;










public function __construct(
OutlinePrinter $outlinePrinter,
ExamplePrinter $examplePrinter,
StepPrinter $stepPrinter,
SetupPrinter $exampleSetupPrinter,
SetupPrinter $stepSetupPrinter
) {
$this->outlinePrinter = $outlinePrinter;
$this->examplePrinter = $examplePrinter;
$this->stepPrinter = $stepPrinter;
$this->exampleSetupPrinter = $exampleSetupPrinter;
$this->stepSetupPrinter = $stepSetupPrinter;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
$this->printAndCaptureOutlineHeaderOnBeforeEvent($formatter, $event);
$this->printAndForgetOutlineFooterOnAfterEvent($formatter, $event);
$this->printExampleHeaderOnBeforeExampleEvent($formatter, $event);
$this->printExampleFooterOnAfterExampleEvent($formatter, $event, $eventName);
$this->printStepSetupOnBeforeStepEvent($formatter, $event);
$this->printStepOnAfterStepEvent($formatter, $event);
}







private function printAndCaptureOutlineHeaderOnBeforeEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof BeforeOutlineTested) {
return;
}

$this->outlinePrinter->printHeader($formatter, $event->getFeature(), $event->getOutline());
}







private function printAndForgetOutlineFooterOnAfterEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof AfterOutlineTested) {
return;
}

$this->outlinePrinter->printFooter($formatter, $event->getTestResult());
}







private function printExampleHeaderOnBeforeExampleEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof AfterScenarioSetup) {
return;
}

$this->example = $event->getScenario();

$this->exampleSetupPrinter->printSetup($formatter, $event->getSetup());
$this->examplePrinter->printHeader($formatter, $event->getFeature(), $this->example);
}








private function printExampleFooterOnAfterExampleEvent(Formatter $formatter, Event $event, $eventName)
{
if (!$event instanceof AfterScenarioTested || ExampleTested::AFTER !== $eventName) {
return;
}

$this->examplePrinter->printFooter($formatter, $event->getTestResult());
$this->exampleSetupPrinter->printTeardown($formatter, $event->getTeardown());

$this->example = null;
}







private function printStepSetupOnBeforeStepEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof AfterStepSetup) {
return;
}

$this->stepSetupPrinter->printSetup($formatter, $event->getSetup());
}







private function printStepOnAfterStepEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof AfterStepTested) {
return;
}

$this->stepPrinter->printStep($formatter, $this->example, $event->getStep(), $event->getTestResult());
$this->stepSetupPrinter->printTeardown($formatter, $event->getTeardown());
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\AST;

use Behat\Behat\EventDispatcher\Event\AfterOutlineTested;
use Behat\Behat\EventDispatcher\Event\AfterScenarioSetup;
use Behat\Behat\EventDispatcher\Event\AfterScenarioTested;
use Behat\Behat\EventDispatcher\Event\AfterStepSetup;
use Behat\Behat\EventDispatcher\Event\AfterStepTested;
use Behat\Behat\EventDispatcher\Event\BeforeOutlineTested;
use Behat\Behat\EventDispatcher\Event\ExampleTested;
use Behat\Behat\EventDispatcher\Event\OutlineTested;
use Behat\Behat\EventDispatcher\Event\StepTested;
use Behat\Behat\Output\Node\Printer\ExampleRowPrinter;
use Behat\Behat\Output\Node\Printer\OutlineTablePrinter;
use Behat\Behat\Output\Node\Printer\SetupPrinter;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Behat\Testwork\Tester\Setup\Setup;
use Symfony\Component\EventDispatcher\Event;






final class OutlineTableListener implements EventListener
{



private $tablePrinter;



private $exampleRowPrinter;



private $stepSetupPrinter;



private $exampleSetupPrinter;



private $outline;



private $exampleSetup;



private $headerPrinted = false;



private $stepBeforeTestedEvents = array();



private $stepAfterTestedEvents = array();









public function __construct(
OutlineTablePrinter $tablePrinter,
ExampleRowPrinter $exampleRowPrinter,
SetupPrinter $exampleSetupPrinter,
SetupPrinter $stepSetupPrinter
) {
$this->tablePrinter = $tablePrinter;
$this->exampleRowPrinter = $exampleRowPrinter;
$this->exampleSetupPrinter = $exampleSetupPrinter;
$this->stepSetupPrinter = $stepSetupPrinter;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
if ($event instanceof StepTested) {
$this->captureStepEvent($event);

return;
}

$this->captureOutlineOnBeforeOutlineEvent($event);
$this->forgetOutlineOnAfterOutlineEvent($eventName);
$this->captureExampleSetupOnBeforeEvent($event);

$this->printHeaderOnAfterExampleEvent($formatter, $event, $eventName);
$this->printExampleRowOnAfterExampleEvent($formatter, $event, $eventName);
$this->printFooterOnAfterEvent($formatter, $event);
}






private function captureStepEvent(StepTested $event)
{
if ($event instanceof AfterStepSetup) {
$this->stepBeforeTestedEvents[$event->getStep()->getLine()] = $event;
} else {
$this->stepAfterTestedEvents[$event->getStep()->getLine()] = $event;
}
}






private function captureOutlineOnBeforeOutlineEvent(Event $event)
{
if (!$event instanceof BeforeOutlineTested) {
return;
}

$this->outline = $event->getOutline();
$this->headerPrinted = false;
}






private function captureExampleSetupOnBeforeEvent(Event $event)
{
if (!$event instanceof AfterScenarioSetup) {
return;
}

$this->exampleSetup = $event->getSetup();
}






private function forgetOutlineOnAfterOutlineEvent($eventName)
{
if (OutlineTested::AFTER !== $eventName) {
return;
}

$this->outline = null;
}








private function printHeaderOnAfterExampleEvent(Formatter $formatter, Event $event, $eventName)
{
if (!$event instanceof AfterScenarioTested || ExampleTested::AFTER !== $eventName) {
return;
}

if ($this->headerPrinted) {
return;
}

$feature = $event->getFeature();
$stepTestResults = $this->getStepTestResults();

$this->tablePrinter->printHeader($formatter, $feature, $this->outline, $stepTestResults);
$this->headerPrinted = true;
}








private function printExampleRowOnAfterExampleEvent(Formatter $formatter, Event $event, $eventName)
{
if (!$event instanceof AfterScenarioTested || ExampleTested::AFTER !== $eventName) {
return;
}

$example = $event->getScenario();

$this->exampleSetupPrinter->printSetup($formatter, $this->exampleSetup);

foreach ($this->stepBeforeTestedEvents as $beforeEvent) {
$this->stepSetupPrinter->printSetup($formatter, $beforeEvent->getSetup());
}

$this->exampleRowPrinter->printExampleRow($formatter, $this->outline, $example, $this->stepAfterTestedEvents);

foreach ($this->stepAfterTestedEvents as $afterEvent) {
$this->stepSetupPrinter->printTeardown($formatter, $afterEvent->getTeardown());
}

$this->exampleSetupPrinter->printTeardown($formatter, $event->getTeardown());

$this->exampleSetup = null;
$this->stepBeforeTestedEvents = array();
$this->stepAfterTestedEvents = array();
}







private function printFooterOnAfterEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof AfterOutlineTested) {
return;
}

$this->tablePrinter->printFooter($formatter, $event->getTestResult());
}






private function getStepTestResults()
{
return array_map(
function (AfterStepTested $event) {
return $event->getTestResult();
},
$this->stepAfterTestedEvents
);
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\AST;

use Behat\Behat\EventDispatcher\Event\ScenarioLikeTested;
use Behat\Behat\Output\Node\Printer\ScenarioPrinter;
use Behat\Behat\Output\Node\Printer\SetupPrinter;
use Behat\Testwork\EventDispatcher\Event\AfterSetup;
use Behat\Testwork\EventDispatcher\Event\AfterTested;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;






final class ScenarioNodeListener implements EventListener
{



private $beforeEventName;



private $afterEventName;



private $scenarioPrinter;



private $setupPrinter;









public function __construct(
$beforeEventName,
$afterEventName,
ScenarioPrinter $scenarioPrinter,
SetupPrinter $setupPrinter = null
) {
$this->beforeEventName = $beforeEventName;
$this->afterEventName = $afterEventName;
$this->scenarioPrinter = $scenarioPrinter;
$this->setupPrinter = $setupPrinter;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
if (!$event instanceof ScenarioLikeTested) {
return;
}

$this->printHeaderOnBeforeEvent($formatter, $event, $eventName);
$this->printFooterOnAfterEvent($formatter, $event, $eventName);
}








private function printHeaderOnBeforeEvent(Formatter $formatter, ScenarioLikeTested $event, $eventName)
{
if ($this->beforeEventName !== $eventName || !$event instanceof AfterSetup) {
return;
}

if ($this->setupPrinter) {
$this->setupPrinter->printSetup($formatter, $event->getSetup());
}

$this->scenarioPrinter->printHeader($formatter, $event->getFeature(), $event->getScenario());
}








private function printFooterOnAfterEvent(Formatter $formatter, ScenarioLikeTested $event, $eventName)
{
if ($this->afterEventName !== $eventName || !$event instanceof AfterTested) {
return;
}

if ($this->setupPrinter) {
$this->setupPrinter->printTeardown($formatter, $event->getTeardown());
}

$this->scenarioPrinter->printFooter($formatter, $event->getTestResult());
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\AST;

use Behat\Behat\EventDispatcher\Event\AfterStepSetup;
use Behat\Behat\EventDispatcher\Event\AfterStepTested;
use Behat\Behat\EventDispatcher\Event\ExampleTested;
use Behat\Behat\EventDispatcher\Event\ScenarioLikeTested;
use Behat\Behat\EventDispatcher\Event\ScenarioTested;
use Behat\Behat\Output\Node\Printer\SetupPrinter;
use Behat\Behat\Output\Node\Printer\StepPrinter;
use Behat\Gherkin\Node\ScenarioLikeInterface;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;






final class StepListener implements EventListener
{



private $stepPrinter;



private $scenario;



private $setupPrinter;







public function __construct(StepPrinter $stepPrinter, SetupPrinter $setupPrinter = null)
{
$this->stepPrinter = $stepPrinter;
$this->setupPrinter = $setupPrinter;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
$this->captureScenarioOnScenarioEvent($event);
$this->forgetScenarioOnAfterEvent($eventName);
$this->printStepSetupOnBeforeEvent($formatter, $event);
$this->printStepOnAfterEvent($formatter, $event);
}






private function captureScenarioOnScenarioEvent(Event $event)
{
if (!$event instanceof ScenarioLikeTested) {
return;
}

$this->scenario = $event->getScenario();
}






private function forgetScenarioOnAfterEvent($eventName)
{
if (!in_array($eventName, array(ScenarioTested::AFTER, ExampleTested::AFTER))) {
return;
}

$this->scenario = null;
}

private function printStepSetupOnBeforeEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof AfterStepSetup) {
return;
}

if ($this->setupPrinter) {
$this->setupPrinter->printSetup($formatter, $event->getSetup());
}
}







private function printStepOnAfterEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof AfterStepTested) {
return;
}

$this->stepPrinter->printStep($formatter, $this->scenario, $event->getStep(), $event->getTestResult());

if ($this->setupPrinter) {
$this->setupPrinter->printTeardown($formatter, $event->getTeardown());
}
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\AST;

use Behat\Behat\Output\Node\Printer\SetupPrinter;
use Behat\Testwork\EventDispatcher\Event\AfterSuiteSetup;
use Behat\Testwork\EventDispatcher\Event\AfterSuiteTested;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;






final class SuiteListener implements EventListener
{



private $setupPrinter;






public function __construct(SetupPrinter $setupPrinter)
{
$this->setupPrinter = $setupPrinter;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
if ($event instanceof AfterSuiteSetup) {
$this->setupPrinter->printSetup($formatter, $event->getSetup());
}

if ($event instanceof AfterSuiteTested) {
$this->setupPrinter->printTeardown($formatter, $event->getTeardown());
}
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\Flow;

use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;









class FireOnlySiblingsListener implements EventListener
{



private $beforeEventName;



private $afterEventName;



private $descendant;



private $inContext = false;








public function __construct($beforeEventName, $afterEventName, EventListener $descendant)
{
$this->beforeEventName = $beforeEventName;
$this->afterEventName = $afterEventName;
$this->descendant = $descendant;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
if ($this->beforeEventName === $eventName) {
$this->inContext = true;
}

if ($this->inContext) {
$this->descendant->listenEvent($formatter, $event, $eventName);
}

if ($this->afterEventName === $eventName) {
$this->inContext = false;
}
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\Flow;

use Behat\Behat\EventDispatcher\Event\BackgroundTested;
use Behat\Behat\EventDispatcher\Event\ExampleTested;
use Behat\Behat\EventDispatcher\Event\FeatureTested;
use Behat\Behat\EventDispatcher\Event\OutlineTested;
use Behat\Behat\EventDispatcher\Event\ScenarioTested;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;









class FirstBackgroundFiresFirstListener implements EventListener
{



private $descendant;



private $firstBackgroundEnded = false;



private $delayedUntilBackgroundEnd = array();






public function __construct(EventListener $descendant)
{
$this->descendant = $descendant;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
$this->flushStatesIfBeginningOfTheFeature($eventName);
$this->markFirstBackgroundPrintedAfterBackground($eventName);

if ($this->isEventDelayedUntilFirstBackgroundPrinted($event)) {
$this->delayedUntilBackgroundEnd[] = array($event, $eventName);

return;
}

$this->descendant->listenEvent($formatter, $event, $eventName);
$this->fireDelayedEventsOnAfterBackground($formatter, $eventName);
}






private function flushStatesIfBeginningOfTheFeature($eventName)
{
if (FeatureTested::BEFORE !== $eventName) {
return;
}

$this->firstBackgroundEnded = false;
}






private function markFirstBackgroundPrintedAfterBackground($eventName)
{
if (BackgroundTested::AFTER !== $eventName) {
return;
}

$this->firstBackgroundEnded = true;
}








private function isEventDelayedUntilFirstBackgroundPrinted(Event $event)
{
if (!$event instanceof ScenarioTested && !$event instanceof OutlineTested && !$event instanceof ExampleTested) {
return false;
}

return !$this->firstBackgroundEnded && $event->getFeature()->hasBackground();
}







private function fireDelayedEventsOnAfterBackground(Formatter $formatter, $eventName)
{
if (BackgroundTested::AFTER !== $eventName) {
return;
}

foreach ($this->delayedUntilBackgroundEnd as $eventInfo) {
list($event, $eventName) = $eventInfo;

$this->descendant->listenEvent($formatter, $event, $eventName);
}

$this->delayedUntilBackgroundEnd = array();
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\Flow;

use Behat\Behat\EventDispatcher\Event\AfterStepSetup;
use Behat\Behat\EventDispatcher\Event\AfterStepTested;
use Behat\Behat\EventDispatcher\Event\BackgroundTested;
use Behat\Behat\EventDispatcher\Event\FeatureTested;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;












class OnlyFirstBackgroundFiresListener implements EventListener
{



private $descendant;



private $firstBackgroundEnded = false;



private $inBackground = false;



private $stepSetupHadOutput = false;






public function __construct(EventListener $descendant)
{
$this->descendant = $descendant;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
$this->flushStatesIfBeginningOfTheFeature($eventName);
$this->markBeginningOrEndOfTheBackground($eventName);

if ($this->isSkippableEvent($event)) {
return;
}

$this->markFirstBackgroundPrintedAfterBackground($eventName);

$this->descendant->listenEvent($formatter, $event, $eventName);
}






private function flushStatesIfBeginningOfTheFeature($eventName)
{
if (FeatureTested::BEFORE !== $eventName) {
return;
}

$this->firstBackgroundEnded = false;
$this->inBackground = false;
}






private function markBeginningOrEndOfTheBackground($eventName)
{
if (BackgroundTested::BEFORE === $eventName) {
$this->inBackground = true;
}

if (BackgroundTested::AFTER === $eventName) {
$this->inBackground = false;
}
}






private function markFirstBackgroundPrintedAfterBackground($eventName)
{
if (BackgroundTested::AFTER !== $eventName) {
return;
}

$this->firstBackgroundEnded = true;
}








private function isSkippableEvent(Event $event)
{
if (!$this->firstBackgroundEnded) {
return false;
}

return $event instanceof BackgroundTested || $this->isNonFailingConsequentBackgroundStep($event);
}








private function isNonFailingConsequentBackgroundStep(Event $event)
{
if (!$this->inBackground) {
return false;
}

return !$this->isStepEventWithOutput($event);
}








private function isStepEventWithOutput(Event $event)
{
return $this->isBeforeStepEventWithOutput($event) || $this->isAfterStepWithOutput($event);
}








private function isBeforeStepEventWithOutput(Event $event)
{
if ($event instanceof AfterStepSetup && $event->hasOutput()) {
$this->stepSetupHadOutput = true;

return true;
}

return false;
}








private function isAfterStepWithOutput(Event $event)
{
if ($event instanceof AfterStepTested && ($this->stepSetupHadOutput || $event->hasOutput())) {
$this->stepSetupHadOutput = false;

return true;
}

return false;
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\JUnit;

use Behat\Behat\EventDispatcher\Event\AfterFeatureTested;
use Behat\Behat\EventDispatcher\Event\AfterScenarioTested;
use Behat\Behat\EventDispatcher\Event\AfterStepSetup;
use Behat\Behat\EventDispatcher\Event\AfterStepTested;
use Behat\Behat\EventDispatcher\Event\BeforeFeatureTested;
use Behat\Behat\EventDispatcher\Event\ScenarioTested;
use Behat\Behat\EventDispatcher\Event\StepTested;
use Behat\Behat\Output\Node\Printer\FeaturePrinter;
use Behat\Behat\Output\Node\Printer\JUnit\JUnitScenarioPrinter;
use Behat\Behat\Output\Node\Printer\SetupPrinter;
use Behat\Behat\Output\Node\Printer\StepPrinter;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\EventDispatcher\Event\AfterSetup;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;






final class JUnitFeatureElementListener implements EventListener
{



private $featurePrinter;



private $scenarioPrinter;



private $stepPrinter;



private $setupPrinter;



private $beforeFeatureTestedEvent;



private $afterScenarioTestedEvents = array();



private $afterStepTestedEvents = array();



private $afterStepSetupEvents = array();









public function __construct(FeaturePrinter $featurePrinter,
JUnitScenarioPrinter $scenarioPrinter,
StepPrinter $stepPrinter,
SetupPrinter $setupPrinter)
{
$this->featurePrinter = $featurePrinter;
$this->scenarioPrinter = $scenarioPrinter;
$this->stepPrinter = $stepPrinter;
$this->setupPrinter = $setupPrinter;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
if ($event instanceof ScenarioTested) {
$this->captureScenarioEvent($event);
}

if ($event instanceof StepTested
|| $event instanceof AfterStepSetup
) {
$this->captureStepEvent($event);
}

$this->captureFeatureOnBeforeEvent($event);
$this->printFeatureOnAfterEvent($formatter, $event);
}






private function captureScenarioEvent(ScenarioTested $event)
{
if ($event instanceof AfterScenarioTested) {
$this->afterScenarioTestedEvents[$event->getScenario()->getLine()] = array(
'event' => $event,
'step_events' => $this->afterStepTestedEvents,
'step_setup_events' => $this->afterStepSetupEvents,
);

$this->afterStepTestedEvents = array();
$this->afterStepSetupEvents = array();
}
}






private function captureFeatureOnBeforeEvent(Event $event)
{
if (!$event instanceof BeforeFeatureTested) {
return;
}

$this->beforeFeatureTestedEvent = $event->getFeature();
}






private function captureStepEvent(Event $event)
{
if ($event instanceof AfterStepTested) {
$this->afterStepTestedEvents[$event->getStep()->getLine()] = $event;
}
if ($event instanceof AfterStepSetup) {
$this->afterStepSetupEvents[$event->getStep()->getLine()] = $event;
}
}







public function printFeatureOnAfterEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof AfterFeatureTested) {
return;
}

$this->featurePrinter->printHeader($formatter, $this->beforeFeatureTestedEvent);

foreach ($this->afterScenarioTestedEvents as $afterScenario) {
$afterScenarioTested = $afterScenario['event'];
$this->scenarioPrinter->printOpenTag($formatter, $afterScenarioTested->getFeature(), $afterScenarioTested->getScenario(), $afterScenarioTested->getTestResult());


foreach ($afterScenario['step_setup_events'] as $afterStepSetup) {
$this->setupPrinter->printSetup($formatter, $afterStepSetup->getSetup());
}
foreach ($afterScenario['step_events'] as $afterStepTested) {
$this->stepPrinter->printStep($formatter, $afterScenarioTested->getScenario(), $afterStepTested->getStep(), $afterStepTested->getTestResult());
$this->setupPrinter->printTeardown($formatter, $afterStepTested->getTeardown());
}
}

$this->featurePrinter->printFooter($formatter, $event->getTestResult());
$this->afterScenarioTestedEvents = array();
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\JUnit;

use Behat\Behat\EventDispatcher\Event\BeforeOutlineTested;
use Behat\Behat\Output\Node\Printer\SuitePrinter;
use Behat\Gherkin\Node\ExampleNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\EventDispatcher\Event\AfterSuiteTested;
use Behat\Testwork\EventDispatcher\Event\BeforeSuiteTested;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;






final class JUnitOutlineStoreListener implements EventListener
{




private $suitePrinter;




private $lineScenarioMap = array();






public function __construct(SuitePrinter $suitePrinter)
{
$this->suitePrinter = $suitePrinter;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
$this->captureOutlineOnBeforeOutlineEvent($event);

$this->printHeaderOnBeforeSuiteTestedEvent($formatter, $event);
$this->printFooterOnAfterSuiteTestedEvent($formatter, $event);
}






private function captureOutlineOnBeforeOutlineEvent(Event $event)
{
if (!$event instanceof BeforeOutlineTested) {
return;
}

$outline = $event->getOutline();
foreach ($outline->getExamples() as $example) {
$this->lineScenarioMap[$example->getLine()] = $outline;
}
}





private function printHeaderOnBeforeSuiteTestedEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof BeforeSuiteTested) {
return;
}
$this->suitePrinter->printHeader($formatter, $event->getSuite());
}





private function printFooterOnAfterSuiteTestedEvent(Formatter $formatter, Event $event)
{
if (!$event instanceof AfterSuiteTested) {
return;
}
$this->suitePrinter->printFooter($formatter, $event->getSuite());
}





public function getCurrentOutline(ExampleNode $scenario)
{
return $this->lineScenarioMap[$scenario->getLine()];
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\Statistics;

use Behat\Behat\Output\Statistics\HookStat;
use Behat\Behat\Output\Statistics\Statistics;
use Behat\Testwork\Call\CallResult;
use Behat\Testwork\EventDispatcher\Event\AfterSetup;
use Behat\Testwork\EventDispatcher\Event\AfterTested;
use Behat\Testwork\Exception\ExceptionPresenter;
use Behat\Testwork\Hook\Tester\Setup\HookedSetup;
use Behat\Testwork\Hook\Tester\Setup\HookedTeardown;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;






final class HookStatsListener implements EventListener
{



private $statistics;



private $exceptionPresenter;







public function __construct(Statistics $statistics, ExceptionPresenter $exceptionPresenter)
{
$this->statistics = $statistics;
$this->exceptionPresenter = $exceptionPresenter;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
$this->captureHookStatsOnEvent($event);
}






private function captureHookStatsOnEvent(Event $event)
{
if ($event instanceof AfterSetup && $event->getSetup() instanceof HookedSetup) {
$this->captureBeforeHookStats($event->getSetup());
}

if ($event instanceof AfterTested && $event->getTeardown() instanceof HookedTeardown) {
$this->captureAfterHookStats($event->getTeardown());
}
}






private function captureBeforeHookStats(HookedSetup $setup)
{
$hookCallResults = $setup->getHookCallResults();

foreach ($hookCallResults as $hookCallResult) {
$this->captureHookStat($hookCallResult);
}
}






private function captureAfterHookStats(HookedTeardown $teardown)
{
$hookCallResults = $teardown->getHookCallResults();

foreach ($hookCallResults as $hookCallResult) {
$this->captureHookStat($hookCallResult);
}
}






private function captureHookStat(CallResult $hookCallResult)
{
$callee = $hookCallResult->getCall()->getCallee();
$hook = (string) $callee;
$path = $callee->getPath();
$stdOut = $hookCallResult->getStdOut();
$error = $hookCallResult->getException()
? $this->exceptionPresenter->presentException($hookCallResult->getException())
: null;

$stat = new HookStat($hook, $path, $error, $stdOut);
$this->statistics->registerHookStat($stat);
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\Statistics;

use Behat\Behat\EventDispatcher\Event\AfterFeatureTested;
use Behat\Behat\EventDispatcher\Event\AfterScenarioTested;
use Behat\Behat\EventDispatcher\Event\BeforeFeatureTested;
use Behat\Behat\Output\Statistics\ScenarioStat;
use Behat\Behat\Output\Statistics\Statistics;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;






final class ScenarioStatsListener implements EventListener
{



private $statistics;



private $currentFeaturePath;






public function __construct(Statistics $statistics)
{
$this->statistics = $statistics;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
$this->captureCurrentFeaturePathOnBeforeFeatureEvent($event);
$this->forgetCurrentFeaturePathOnAfterFeatureEvent($event);
$this->captureScenarioOrExampleStatsOnAfterEvent($event);
}






private function captureCurrentFeaturePathOnBeforeFeatureEvent(Event $event)
{
if (!$event instanceof BeforeFeatureTested) {
return;
}

$this->currentFeaturePath = $event->getFeature()->getFile();
}






private function forgetCurrentFeaturePathOnAfterFeatureEvent($event)
{
if (!$event instanceof AfterFeatureTested) {
return;
}

$this->currentFeaturePath = null;
}






private function captureScenarioOrExampleStatsOnAfterEvent(Event $event)
{
if (!$event instanceof AfterScenarioTested) {
return;
}

$scenario = $event->getScenario();
$title = $scenario->getTitle();
$path = sprintf('%s:%d', $this->currentFeaturePath, $scenario->getLine());
$resultCode = $event->getTestResult()->getResultCode();

$stat = new ScenarioStat($title, $path, $resultCode);
$this->statistics->registerScenarioStat($stat);
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\Statistics;

use Behat\Behat\Output\Node\Printer\StatisticsPrinter;
use Behat\Behat\Output\Statistics\Statistics;
use Behat\Testwork\EventDispatcher\Event\ExerciseCompleted;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Symfony\Component\EventDispatcher\Event;






final class StatisticsListener implements EventListener
{



private $statistics;



private $printer;







public function __construct(Statistics $statistics, StatisticsPrinter $statisticsPrinter)
{
$this->statistics = $statistics;
$this->printer = $statisticsPrinter;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
$this->startTimerOnBeforeExercise($eventName);
$this->printStatisticsOnAfterExerciseEvent($formatter, $eventName);
}






private function startTimerOnBeforeExercise($eventName)
{
if (ExerciseCompleted::BEFORE !== $eventName) {
return;
}

$this->statistics->startTimer();
}







private function printStatisticsOnAfterExerciseEvent(Formatter $formatter, $eventName)
{
if (ExerciseCompleted::AFTER !== $eventName) {
return;
}

$this->statistics->stopTimer();
$this->printer->printStatistics($formatter, $this->statistics);
}
}
<?php









namespace Behat\Behat\Output\Node\EventListener\Statistics;

use Behat\Behat\EventDispatcher\Event\AfterStepTested;
use Behat\Behat\EventDispatcher\Event\BeforeFeatureTested;
use Behat\Behat\EventDispatcher\Event\BeforeScenarioTested;
use Behat\Behat\EventDispatcher\Event\FeatureTested;
use Behat\Behat\EventDispatcher\Event\ScenarioTested;
use Behat\Behat\Output\Statistics\StepStatV2;
use Behat\Behat\Output\Statistics\Statistics;
use Behat\Behat\Output\Statistics\StepStat;
use Behat\Behat\Tester\Exception\PendingException;
use Behat\Behat\Tester\Result\ExecutedStepResult;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Testwork\Exception\ExceptionPresenter;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Node\EventListener\EventListener;
use Behat\Testwork\Tester\Result\ExceptionResult;
use Exception;
use Symfony\Component\EventDispatcher\Event;






final class StepStatsListener implements EventListener
{



private $statistics;



private $currentFeaturePath;



private $exceptionPresenter;



private $scenarioTitle;



private $scenarioPath;







public function __construct(Statistics $statistics, ExceptionPresenter $exceptionPresenter)
{
$this->statistics = $statistics;
$this->exceptionPresenter = $exceptionPresenter;
}




public function listenEvent(Formatter $formatter, Event $event, $eventName)
{
$this->captureCurrentFeaturePathOnBeforeFeatureEvent($event);
$this->forgetCurrentFeaturePathOnAfterFeatureEvent($eventName);
$this->captureScenarioOnBeforeFeatureEvent($event);
$this->forgetScenarioOnAfterFeatureEvent($eventName);
$this->captureStepStatsOnAfterEvent($event);
}






private function captureCurrentFeaturePathOnBeforeFeatureEvent(Event $event)
{
if (!$event instanceof BeforeFeatureTested) {
return;
}

$this->currentFeaturePath = $event->getFeature()->getFile();
}






private function forgetCurrentFeaturePathOnAfterFeatureEvent($eventName)
{
if (FeatureTested::AFTER !== $eventName) {
return;
}

$this->currentFeaturePath = null;
}






private function captureScenarioOnBeforeFeatureEvent(Event $event)
{
if (!$event instanceof BeforeScenarioTested) {
return;
}

$this->scenarioTitle = sprintf('%s: %s', $event->getScenario()->getKeyword(), $event->getScenario()->getTitle());
$this->scenarioPath = sprintf('%s:%s', $this->currentFeaturePath, $event->getScenario()->getLine());
}

private function forgetScenarioOnAfterFeatureEvent($eventName)
{
if (ScenarioTested::AFTER !== $eventName) {
return;
}

$this->scenarioTitle = $this->scenarioPath = null;
}






private function captureStepStatsOnAfterEvent(Event $event)
{
if (!$event instanceof AfterStepTested) {
return;
}

$result = $event->getTestResult();
$step = $event->getStep();
$text = sprintf('%s %s', $step->getKeyword(), $step->getText());
$exception = $this->getStepException($result);

$path = $this->getStepPath($event, $exception);
$error = $exception ? $this->exceptionPresenter->presentException($exception) : null;
$stdOut = $result instanceof ExecutedStepResult ? $result->getCallResult()->getStdOut() : null;

$resultCode = $result->getResultCode();
$stat = new StepStatV2($this->scenarioTitle, $this->scenarioPath, $text, $path, $resultCode, $error, $stdOut);

$this->statistics->registerStepStat($stat);
}








private function getStepException(StepResult $result)
{
if ($result instanceof ExceptionResult) {
return $result->getException();
}

return null;
}









private function getStepPath(AfterStepTested $event, Exception $exception = null)
{
$path = sprintf('%s:%d', $this->currentFeaturePath, $event->getStep()->getLine());

if ($exception && $exception instanceof PendingException) {
$path = $event->getTestResult()->getStepDefinition()->getPath();
}

return $path;
}
}
<?php









namespace Behat\Behat\Output\Node\Printer;

use Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter;
use Behat\Testwork\Output\Printer\OutputPrinter;
use Symfony\Component\Translation\TranslatorInterface;






final class CounterPrinter
{



private $resultConverter;



private $translator;







public function __construct(ResultToStringConverter $resultConverter, TranslatorInterface $translator)
{
$this->resultConverter = $resultConverter;
$this->translator = $translator;
}








public function printCounters(OutputPrinter $printer, $intro, array $stats)
{
$stats = array_filter($stats, function ($count) { return 0 !== $count; });

if (0 === count($stats)) {
$totalCount = 0;
} else {
$totalCount = array_sum($stats);
}

$detailedStats = array();
foreach ($stats as $resultCode => $count) {
$style = $this->resultConverter->convertResultCodeToString($resultCode);

$transId = $style . '_count';
$message = $this->translator->transChoice($transId, $count, array('%1%' => $count), 'output');

$detailedStats[] = sprintf('{+%s}%s{-%s}', $style, $message, $style);
}

$message = $this->translator->transChoice($intro, $totalCount, array('%1%' => $totalCount), 'output');
$printer->write($message);

if (count($detailedStats)) {
$printer->write(sprintf(' (%s)', implode(', ', $detailedStats)));
}

$printer->writeln();
}
}
<?php









namespace Behat\Behat\Output\Node\Printer;

use Behat\Gherkin\Node\ExampleNode;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Tester\Result\TestResult;






interface ExamplePrinter
{







public function printHeader(Formatter $formatter, FeatureNode $feature, ExampleNode $example);







public function printFooter(Formatter $formatter, TestResult $result);
}
<?php









namespace Behat\Behat\Output\Node\Printer;

use Behat\Behat\EventDispatcher\Event\AfterStepTested;
use Behat\Gherkin\Node\ExampleNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\Output\Formatter;






interface ExampleRowPrinter
{








public function printExampleRow(Formatter $formatter, OutlineNode $outline, ExampleNode $example, array $events);
}
<?php









namespace Behat\Behat\Output\Node\Printer;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Tester\Result\TestResult;






interface FeaturePrinter
{






public function printHeader(Formatter $formatter, FeatureNode $feature);







public function printFooter(Formatter $formatter, TestResult $result);
}
<?php









namespace Behat\Behat\Output\Node\Printer\Helper;

use Behat\Behat\Tester\Result\StepResult;
use Behat\Testwork\Tester\Result\TestResult;






final class ResultToStringConverter
{







public function convertResultToString(TestResult $result)
{
return $this->convertResultCodeToString($result->getResultCode());
}








public function convertResultCodeToString($resultCode)
{
switch ($resultCode) {
case TestResult::SKIPPED:
return 'skipped';
case TestResult::PENDING:
return 'pending';
case TestResult::FAILED:
return 'failed';
case StepResult::UNDEFINED:
return 'undefined';
}

return 'passed';
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Helper;

use Behat\Behat\Definition\Definition;
use Behat\Behat\Definition\Pattern\PatternTransformer;
use Behat\Testwork\Tester\Result\TestResult;






final class StepTextPainter
{



private $patternTransformer;



private $resultConverter;







public function __construct(PatternTransformer $patternTransformer, ResultToStringConverter $resultConverter)
{
$this->patternTransformer = $patternTransformer;
$this->resultConverter = $resultConverter;
}










public function paintText($text, Definition $definition, TestResult $result)
{
$regex = $this->patternTransformer->transformPatternToRegex($definition->getPattern());
$style = $this->resultConverter->convertResultToString($result);
$paramStyle = $style . '_param';


 if ('/' !== substr($regex, 0, 1)) {
return $text;
}


 $matches = array();
preg_match($regex, $text, $matches, PREG_OFFSET_CAPTURE);
array_shift($matches);


 $shift = 0;
$lastReplacementPosition = 0;
foreach ($matches as $key => $match) {
if (!is_numeric($key) || -1 === $match[1] || false !== strpos($match[0], '<')) {
continue;
}

$offset = $match[1] + $shift;
$value = $match[0];


 if ($lastReplacementPosition > $offset) {
continue;
}
$lastReplacementPosition = $offset + strlen($value);

$begin = substr($text, 0, $offset);
$end = substr($text, $lastReplacementPosition);
$format = "{-$style}{+$paramStyle}%s{-$paramStyle}{+$style}";
$text = sprintf("%s{$format}%s", $begin, $value, $end);


 $shift += strlen($format) - 2;
$lastReplacementPosition += strlen($format) - 2;
}


 $text = preg_replace(
'/(<[^>]+>)/',
"{-$style}{+$paramStyle}\$1{-$paramStyle}{+$style}",
$text
);

return $text;
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Helper;

use Behat\Gherkin\Node\ExampleNode;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Gherkin\Node\StepNode;






final class WidthCalculator
{









public function calculateScenarioWidth(Scenario $scenario, $indentation, $subIndentation)
{
$length = $this->calculateScenarioHeaderWidth($scenario, $indentation);

foreach ($scenario->getSteps() as $step) {
$stepLength = $this->calculateStepWidth($step, $indentation + $subIndentation);
$length = max($length, $stepLength);
}

return $length;
}










public function calculateExampleWidth(ExampleNode $example, $indentation, $subIndentation)
{
$length = $this->calculateScenarioHeaderWidth($example, $indentation);

foreach ($example->getSteps() as $step) {
$stepLength = $this->calculateStepWidth($step, $indentation + $subIndentation);
$length = max($length, $stepLength);
}

return $length;
}









public function calculateScenarioHeaderWidth(Scenario $scenario, $indentation)
{
$indentText = str_repeat(' ', intval($indentation));

if ($scenario instanceof ExampleNode) {
$header = sprintf('%s%s', $indentText, $scenario->getTitle());
} else {
$title = $scenario->getTitle();
$lines = explode("\n", $title);
$header = sprintf('%s%s: %s', $indentText, $scenario->getKeyword(), array_shift($lines));
}

return mb_strlen(rtrim($header), 'utf8');
}









public function calculateStepWidth(StepNode $step, $indentation)
{
$indentText = str_repeat(' ', intval($indentation));

$text = sprintf('%s%s %s', $indentText, $step->getKeyword(), $step->getText());

return mb_strlen($text, 'utf8');
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\JUnit;

use Behat\Behat\Output\Node\Printer\FeaturePrinter;
use Behat\Behat\Output\Statistics\PhaseStatistics;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\JUnitOutputPrinter;
use Behat\Testwork\Tester\Result\TestResult;






final class JUnitFeaturePrinter implements FeaturePrinter
{



private $statistics;

public function __construct(PhaseStatistics $statistics)
{
$this->statistics = $statistics;
}




public function printHeader(Formatter $formatter, FeatureNode $feature)
{
$stats = $this->statistics->getScenarioStatCounts();

if (0 === count($stats)) {
$totalCount = 0;
} else {
$totalCount = array_sum($stats);
}


$outputPrinter = $formatter->getOutputPrinter();

$outputPrinter->addTestsuite(array(
'name' => $feature->getTitle(),
'tests' => $totalCount,
'skipped' => $stats[TestResult::SKIPPED],
'failures' => $stats[TestResult::FAILED],
'errors' => $stats[TestResult::PENDING] + $stats[StepResult::UNDEFINED],
));
$this->statistics->reset();
}




public function printFooter(Formatter $formatter, TestResult $result)
{
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\JUnit;

use Behat\Behat\Output\Node\EventListener\JUnit\JUnitOutlineStoreListener;
use Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter;
use Behat\Gherkin\Node\ExampleNode;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Gherkin\Node\ScenarioLikeInterface;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\JUnitOutputPrinter;
use Behat\Testwork\Tester\Result\TestResult;






final class JUnitScenarioPrinter
{



private $resultConverter;




private $outlineStoreListener;




private $lastOutline;




private $outlineStepCount;

public function __construct(ResultToStringConverter $resultConverter, JUnitOutlineStoreListener $outlineListener)
{
$this->resultConverter = $resultConverter;
$this->outlineStoreListener = $outlineListener;
}




public function printOpenTag(Formatter $formatter, FeatureNode $feature, ScenarioLikeInterface $scenario, TestResult $result)
{
$name = implode(' ', array_map(function ($l) {
return trim($l);
}, explode("\n", $scenario->getTitle())));

if ($scenario instanceof ExampleNode) {
$name = $this->buildExampleName($scenario);
}


$outputPrinter = $formatter->getOutputPrinter();

$outputPrinter->addTestcase(array(
'name' => $name,
'status' => $this->resultConverter->convertResultToString($result)
));
}





private function buildExampleName(ExampleNode $scenario)
{
$currentOutline = $this->outlineStoreListener->getCurrentOutline($scenario);
if ($currentOutline === $this->lastOutline) {
$this->outlineStepCount++;
} else {
$this->lastOutline = $currentOutline;
$this->outlineStepCount = 1;
}

$name = $currentOutline->getTitle() . ' #' . $this->outlineStepCount;
return $name;
}
}
<?php
namespace Behat\Behat\Output\Node\Printer\JUnit;

use Behat\Behat\Hook\Scope\StepScope;
use Behat\Behat\Output\Node\Printer\SetupPrinter;
use Behat\Testwork\Call\CallResult;
use Behat\Testwork\Call\CallResults;
use Behat\Testwork\Exception\ExceptionPresenter;
use Behat\Testwork\Hook\Call\HookCall;
use Behat\Testwork\Hook\Tester\Setup\HookedSetup;
use Behat\Testwork\Hook\Tester\Setup\HookedTeardown;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\JUnitOutputPrinter;
use Behat\Testwork\Tester\Setup\Setup;
use Behat\Testwork\Tester\Setup\Teardown;




class JUnitSetupPrinter implements SetupPrinter
{


private $exceptionPresenter;

public function __construct(ExceptionPresenter $exceptionPresenter)
{
$this->exceptionPresenter = $exceptionPresenter;
}




public function printSetup(Formatter $formatter, Setup $setup)
{
if (!$setup->isSuccessful()) {
if ($setup instanceof HookedSetup) {
$this->handleHookCalls($formatter, $setup->getHookCallResults(), 'setup');
}
}
}




public function printTeardown(Formatter $formatter, Teardown $teardown)
{
if (!$teardown->isSuccessful()) {
if ($teardown instanceof HookedTeardown) {
$this->handleHookCalls($formatter, $teardown->getHookCallResults(), 'teardown');
}
}
}






private function handleHookCalls(Formatter $formatter, CallResults $results, $messageType)
{

foreach ($results as $hookCallResult) {
if ($hookCallResult->hasException()) {

$call = $hookCallResult->getCall();
$scope = $call->getScope();

$outputPrinter = $formatter->getOutputPrinter();

$message = '';
if ($scope instanceof StepScope) {
$message .= $scope->getStep()->getKeyword() . ' ' . $scope->getStep()->getText() . ': ';
}
$message .= $this->exceptionPresenter->presentException($hookCallResult->getException());

$attributes = array(
'message' => $message,
'type' => $messageType,
);

$outputPrinter->addTestcaseChild('failure', $attributes);

}
}
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\JUnit;

use Behat\Behat\Tester\Result\StepResult;
use Behat\Behat\Output\Node\Printer\StepPrinter;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Exception\ExceptionPresenter;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\JUnitOutputPrinter;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Result\ExceptionResult;







class JUnitStepPrinter implements StepPrinter
{



private $exceptionPresenter;

public function __construct(ExceptionPresenter $exceptionPresenter)
{
$this->exceptionPresenter = $exceptionPresenter;
}









public function printStep(Formatter $formatter, Scenario $scenario, StepNode $step, StepResult $result)
{

$outputPrinter = $formatter->getOutputPrinter();

$message = $step->getKeyword() . ' ' . $step->getText();

if ($result instanceof ExceptionResult && $result->hasException()) {
$message .= ': ' . $this->exceptionPresenter->presentException($result->getException());
}

$attributes = array('message' => $message);

switch ($result->getResultCode()) {
case TestResult::FAILED:
$outputPrinter->addTestcaseChild('failure', $attributes);
break;

case TestResult::PENDING:
$attributes['type'] = 'pending';
$outputPrinter->addTestcaseChild('error', $attributes);
break;

case StepResult::UNDEFINED:
$attributes['type'] = 'undefined';
$outputPrinter->addTestcaseChild('error', $attributes);
break;
}
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\JUnit;

use Behat\Behat\Output\Node\Printer\SuitePrinter;
use Behat\Behat\Output\Statistics\PhaseStatistics;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\JUnitOutputPrinter;
use Behat\Testwork\Suite\Suite;






final class JUnitSuitePrinter implements SuitePrinter
{



private $statistics;

public function __construct(PhaseStatistics $statistics = null)
{
$this->statistics = $statistics;
}




public function printHeader(Formatter $formatter, Suite $suite)
{
if ($this->statistics) {
$this->statistics->reset();
}


$outputPrinter = $formatter->getOutputPrinter();
$outputPrinter->createNewFile($suite->getName());
}




public function printFooter(Formatter $formatter, Suite $suite)
{
$formatter->getOutputPrinter()->flush();
}
}
<?php









namespace Behat\Behat\Output\Node\Printer;

use Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter;
use Behat\Behat\Output\Statistics\HookStat;
use Behat\Behat\Output\Statistics\ScenarioStat;
use Behat\Behat\Output\Statistics\StepStatV2;
use Behat\Behat\Output\Statistics\StepStat;
use Behat\Testwork\Exception\ExceptionPresenter;
use Behat\Testwork\Output\Printer\OutputPrinter;
use Behat\Testwork\Tester\Result\TestResult;
use Symfony\Component\Translation\TranslatorInterface;






final class ListPrinter
{



private $resultConverter;



private $exceptionPresenter;



private $translator;



private $basePath;









public function __construct(
ResultToStringConverter $resultConverter,
ExceptionPresenter $exceptionPresenter,
TranslatorInterface $translator,
$basePath
) {
$this->resultConverter = $resultConverter;
$this->exceptionPresenter = $exceptionPresenter;
$this->translator = $translator;
$this->basePath = $basePath;
}









public function printScenariosList(OutputPrinter $printer, $intro, $resultCode, array $scenarioStats)
{
if (!count($scenarioStats)) {
return;
}

$style = $this->resultConverter->convertResultCodeToString($resultCode);
$intro = $this->translator->trans($intro, array(), 'output');

$printer->writeln(sprintf('--- {+%s}%s{-%s}' . PHP_EOL, $style, $intro, $style));
foreach ($scenarioStats as $stat) {
$path = $this->relativizePaths((string) $stat);
$printer->writeln(sprintf('    {+%s}%s{-%s}', $style, $path, $style));
}

$printer->writeln();
}









public function printStepList(OutputPrinter $printer, $intro, $resultCode, array $stepStats)
{
if (!count($stepStats)) {
return;
}

$style = $this->resultConverter->convertResultCodeToString($resultCode);
$intro = $this->translator->trans($intro, array(), 'output');

$printer->writeln(sprintf('--- {+%s}%s{-%s}' . PHP_EOL, $style, $intro, $style));

foreach ($stepStats as $num => $stepStat) {
if ($stepStat instanceof StepStatV2) {
$this->printStepStat($printer, $num + 1, $stepStat, $style);
} elseif ($stepStat instanceof StepStat) {
$this->printStat($printer, $stepStat->getText(), $stepStat->getPath(), $style, $stepStat->getStdOut(), $stepStat->getError());
}
}
}








public function printFailedHooksList(OutputPrinter $printer, $intro, array $failedHookStats)
{
if (!count($failedHookStats)) {
return;
}

$style = $this->resultConverter->convertResultCodeToString(TestResult::FAILED);
$intro = $this->translator->trans($intro, array(), 'output');

$printer->writeln(sprintf('--- {+%s}%s{-%s}' . PHP_EOL, $style, $intro, $style));
foreach ($failedHookStats as $hookStat) {
$this->printHookStat($printer, $hookStat, $style);
}
}













private function printStat(OutputPrinter $printer, $name, $path, $style, $stdOut, $error)
{
$path = $this->relativizePaths($path);
$printer->writeln(sprintf('    {+%s}%s{-%s} {+comment}# %s{-comment}', $style, $name, $style, $path));

$pad = function ($line) { return '      ' . $line; };

if (null !== $stdOut) {
$padText = function ($line) { return '       ' . $line; };
$stdOutString = array_map($padText, explode("\n", $stdOut));
$printer->writeln(implode("\n", $stdOutString));
}

if ($error) {
$exceptionString = implode("\n", array_map($pad, explode("\n", $error)));
$printer->writeln(sprintf('{+%s}%s{-%s}', $style, $exceptionString, $style));
}

$printer->writeln();
}








private function printHookStat(OutputPrinter $printer, HookStat $hookStat, $style)
{
$printer->writeln(
sprintf('    {+%s}%s{-%s} {+comment}# %s{-comment}',
$style, $hookStat->getName(), $style, $this->relativizePaths($hookStat->getPath())
)
);

$pad = function ($line) { return '      ' . $line; };

if (null !== $hookStat->getStdOut()) {
$padText = function ($line) { return '       ' . $line; };
$stdOutString = array_map($padText, explode("\n", $hookStat->getStdOut()));
$printer->writeln(implode("\n", $stdOutString));
}

if ($hookStat->getError()) {
$exceptionString = implode("\n", array_map($pad, explode("\n", $hookStat->getError())));
$printer->writeln(sprintf('{+%s}%s{-%s}', $style, $exceptionString, $style));
}

$printer->writeln();
}









private function printStepStat(OutputPrinter $printer, $number, StepStatV2 $stat, $style)
{
$maxLength = max(mb_strlen($stat->getScenarioText(), 'utf8'), mb_strlen($stat->getStepText(), 'utf8') + 2) + 1;

$printer->writeln(
sprintf('%03d {+%s}%s{-%s}%s{+comment}# %s{-comment}',
$number,
$style,
$stat->getScenarioText(),
$style,
str_pad(' ', $maxLength - mb_strlen($stat->getScenarioText(), 'utf8')),
$this->relativizePaths($stat->getScenarioPath())
)
);

$printer->writeln(
sprintf('      {+%s}%s{-%s}%s{+comment}# %s{-comment}',
$style,
$stat->getStepText(),
$style,
str_pad(' ', $maxLength - mb_strlen($stat->getStepText(), 'utf8') - 2),
$this->relativizePaths($stat->getStepPath())
)
);

$pad = function ($line) { return '        ' . $line; };

if (null !== $stat->getStdOut()) {
$padText = function ($line) { return '         ' . $line; };
$stdOutString = array_map($padText, explode("\n", $stat->getStdOut()));
$printer->writeln(implode("\n", $stdOutString));
}

if ($stat->getError()) {
$exceptionString = implode("\n", array_map($pad, explode("\n", $stat->getError())));
$printer->writeln(sprintf('{+%s}%s{-%s}', $style, $exceptionString, $style));
}

$printer->writeln();
}








private function relativizePaths($path)
{
if (!$this->basePath) {
return $path;
}

return str_replace($this->basePath . DIRECTORY_SEPARATOR, '', $path);
}
}
<?php









namespace Behat\Behat\Output\Node\Printer;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Tester\Result\TestResult;






interface OutlinePrinter
{







public function printHeader(Formatter $formatter, FeatureNode $feature, OutlineNode $outline);







public function printFooter(Formatter $formatter, TestResult $result);
}
<?php









namespace Behat\Behat\Output\Node\Printer;

use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Tester\Result\TestResult;






interface OutlineTablePrinter
{








public function printHeader(Formatter $formatter, FeatureNode $feature, OutlineNode $outline, array $results);







public function printFooter(Formatter $formatter, TestResult $result);
}
<?php









namespace Behat\Behat\Output\Node\Printer\Pretty;

use Behat\Behat\Output\Node\Printer\ExamplePrinter;
use Behat\Gherkin\Node\ExampleNode;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\OutputPrinter;
use Behat\Testwork\Tester\Result\TestResult;






final class PrettyExamplePrinter implements ExamplePrinter
{



private $pathPrinter;



private $indentText;







public function __construct(PrettyPathPrinter $pathPrinter, $indentation = 6)
{
$this->pathPrinter = $pathPrinter;
$this->indentText = str_repeat(' ', intval($indentation));
}




public function printHeader(Formatter $formatter, FeatureNode $feature, ExampleNode $example)
{
$this->printTitle($formatter->getOutputPrinter(), $example);
$this->pathPrinter->printScenarioPath($formatter, $feature, $example, mb_strlen($this->indentText, 'utf8'));
}




public function printFooter(Formatter $formatter, TestResult $result)
{
}







private function printTitle(OutputPrinter $printer, ExampleNode $example)
{
$printer->write(sprintf('%s%s', $this->indentText, $example->getTitle()));
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Pretty;

use Behat\Behat\EventDispatcher\Event\AfterStepTested;
use Behat\Behat\Output\Node\Printer\ExampleRowPrinter;
use Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter;
use Behat\Behat\Tester\Result\ExecutedStepResult;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\ExampleNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\EventDispatcher\Event\AfterTested;
use Behat\Testwork\Exception\ExceptionPresenter;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\OutputPrinter;
use Behat\Testwork\Tester\Result\ExceptionResult;
use Behat\Testwork\Tester\Result\TestResults;






final class PrettyExampleRowPrinter implements ExampleRowPrinter
{



private $resultConverter;



private $exceptionPresenter;



private $indentText;



private $subIndentText;









public function __construct(
ResultToStringConverter $resultConverter,
ExceptionPresenter $exceptionPresenter,
$indentation = 6,
$subIndentation = 2
) {
$this->resultConverter = $resultConverter;
$this->exceptionPresenter = $exceptionPresenter;
$this->indentText = str_repeat(' ', intval($indentation));
$this->subIndentText = $this->indentText . str_repeat(' ', intval($subIndentation));
}




public function printExampleRow(Formatter $formatter, OutlineNode $outline, ExampleNode $example, array $events)
{
$rowNum = array_search($example, $outline->getExamples()) + 1;
$wrapper = $this->getWrapperClosure($outline, $example, $events);
$row = $outline->getExampleTable()->getRowAsStringWithWrappedValues($rowNum, $wrapper);

$formatter->getOutputPrinter()->writeln(sprintf('%s%s', $this->indentText, $row));
$this->printStepExceptionsAndStdOut($formatter->getOutputPrinter(), $events);
}










private function getWrapperClosure(OutlineNode $outline, ExampleNode $example, array $stepEvents)
{
$resultConverter = $this->resultConverter;

return function ($value, $column) use ($outline, $example, $stepEvents, $resultConverter) {
$results = array();
foreach ($stepEvents as $event) {
$index = array_search($event->getStep(), $example->getSteps());
$header = $outline->getExampleTable()->getRow(0);
$steps = $outline->getSteps();
$outlineStepText = $steps[$index]->getText();

if (false !== strpos($outlineStepText, '<' . $header[$column] . '>')) {
$results[] = $event->getTestResult();
}
}

$result = new TestResults($results);
$style = $resultConverter->convertResultToString($result);

return sprintf('{+%s}%s{-%s}', $style, $value, $style);
};
}







private function printStepExceptionsAndStdOut(OutputPrinter $printer, array $events)
{
foreach ($events as $event) {
$this->printStepStdOut($printer, $event->getTestResult());
$this->printStepException($printer, $event->getTestResult());
}
}







private function printStepException(OutputPrinter $printer, StepResult $result)
{
$style = $this->resultConverter->convertResultToString($result);

if (!$result instanceof ExceptionResult || !$result->hasException()) {
return;
}

$text = $this->exceptionPresenter->presentException($result->getException());
$indentedText = implode("\n", array_map(array($this, 'subIndent'), explode("\n", $text)));
$printer->writeln(sprintf('{+%s}%s{-%s}', $style, $indentedText, $style));
}







private function printStepStdOut(OutputPrinter $printer, StepResult $result)
{
if (!$result instanceof ExecutedStepResult || null === $result->getCallResult()->getStdOut()) {
return;
}

$callResult = $result->getCallResult();
$indentedText = $this->subIndentText;

$pad = function ($line) use ($indentedText) {
return sprintf(
'%s {+stdout}%s{-stdout}', $indentedText, $line
);
};

$printer->writeln(implode("\n", array_map($pad, explode("\n", $callResult->getStdOut()))));
}








private function subIndent($text)
{
return $this->subIndentText . $text;
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Pretty;

use Behat\Behat\Output\Node\Printer\FeaturePrinter;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\TaggedNodeInterface;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\OutputPrinter;
use Behat\Testwork\Tester\Result\TestResult;






final class PrettyFeaturePrinter implements FeaturePrinter
{



private $indentText;



private $subIndentText;







public function __construct($indentation = 0, $subIndentation = 2)
{
$this->indentText = str_repeat(' ', intval($indentation));
$this->subIndentText = $this->indentText . str_repeat(' ', intval($subIndentation));
}




public function printHeader(Formatter $formatter, FeatureNode $feature)
{
if ($feature instanceof TaggedNodeInterface) {
$this->printTags($formatter->getOutputPrinter(), $feature->getTags());
}

$this->printTitle($formatter->getOutputPrinter(), $feature);
$this->printDescription($formatter->getOutputPrinter(), $feature);
}




public function printFooter(Formatter $formatter, TestResult $result)
{
}







private function printTags(OutputPrinter $printer, array $tags)
{
if (!count($tags)) {
return;
}

$tags = array_map(array($this, 'prependTagWithTagSign'), $tags);
$printer->writeln(sprintf('%s{+tag}%s{-tag}', $this->indentText, implode(' ', $tags)));
}







private function printTitle(OutputPrinter $printer, FeatureNode $feature)
{
$printer->write(sprintf('%s{+keyword}%s:{-keyword}', $this->indentText, $feature->getKeyword()));

if ($title = $feature->getTitle()) {
$printer->write(sprintf(' %s', $title));
}

$printer->writeln();
}







private function printDescription(OutputPrinter $printer, FeatureNode $feature)
{
if (!$feature->getDescription()) {
$printer->writeln();

return;
}

foreach (explode("\n", $feature->getDescription()) as $descriptionLine) {
$printer->writeln(sprintf('%s%s', $this->subIndentText, $descriptionLine));
}

$printer->writeln();
}








private function prependTagWithTagSign($tag)
{
return '@' . $tag;
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Pretty;

use Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter;
use Behat\Behat\Output\Node\Printer\OutlinePrinter;
use Behat\Behat\Output\Node\Printer\ScenarioPrinter;
use Behat\Behat\Output\Node\Printer\StepPrinter;
use Behat\Behat\Tester\Result\UndefinedStepResult;
use Behat\Gherkin\Node\ExampleTableNode;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\OutputPrinter;
use Behat\Testwork\Tester\Result\TestResult;






final class PrettyOutlinePrinter implements OutlinePrinter
{



private $scenarioPrinter;



private $stepPrinter;



private $resultConverter;



private $indentText;



private $subIndentText;








public function __construct(
ScenarioPrinter $scenarioPrinter,
StepPrinter $stepPrinter,
ResultToStringConverter $resultConverter,
$indentation = 4,
$subIndentation = 2
) {
$this->scenarioPrinter = $scenarioPrinter;
$this->stepPrinter = $stepPrinter;
$this->resultConverter = $resultConverter;
$this->indentText = str_repeat(' ', intval($indentation));
$this->subIndentText = $this->indentText . str_repeat(' ', intval($subIndentation));
}




public function printHeader(Formatter $formatter, FeatureNode $feature, OutlineNode $outline)
{
$this->scenarioPrinter->printHeader($formatter, $feature, $outline);

$this->printExamplesSteps($formatter, $outline, $outline->getSteps());
$this->printExamplesTableHeader($formatter->getOutputPrinter(), $outline->getExampleTable());
}




public function printFooter(Formatter $formatter, TestResult $result)
{
$formatter->getOutputPrinter()->writeln();
}








private function printExamplesSteps(Formatter $formatter, OutlineNode $outline, array $steps)
{
foreach ($steps as $step) {
$this->stepPrinter->printStep($formatter, $outline, $step, new UndefinedStepResult());
}

$formatter->getOutputPrinter()->writeln();
}







private function printExamplesTableHeader(OutputPrinter $printer, ExampleTableNode $table)
{
$printer->writeln(sprintf('%s{+keyword}%s:{-keyword}', $this->indentText, $table->getKeyword()));

$rowNum = 0;
$wrapper = $this->getWrapperClosure();
$row = $table->getRowAsStringWithWrappedValues($rowNum, $wrapper);

$printer->writeln(sprintf('%s%s', $this->subIndentText, $row));
}






private function getWrapperClosure()
{
$style = $this->resultConverter->convertResultCodeToString(TestResult::SKIPPED);

return function ($col) use ($style) {
return sprintf('{+%s_param}%s{-%s_param}', $style, $col, $style);
};
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Pretty;

use Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter;
use Behat\Behat\Output\Node\Printer\OutlineTablePrinter;
use Behat\Behat\Output\Node\Printer\ScenarioPrinter;
use Behat\Behat\Output\Node\Printer\StepPrinter;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\ExampleTableNode;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\OutputPrinter;
use Behat\Testwork\Tester\Result\TestResult;






final class PrettyOutlineTablePrinter implements OutlineTablePrinter
{



private $scenarioPrinter;



private $stepPrinter;



private $resultConverter;



private $indentText;



private $subIndentText;










public function __construct(
ScenarioPrinter $scenarioPrinter,
StepPrinter $stepPrinter,
ResultToStringConverter $resultConverter,
$indentation = 4,
$subIndentation = 2
) {
$this->scenarioPrinter = $scenarioPrinter;
$this->stepPrinter = $stepPrinter;
$this->resultConverter = $resultConverter;
$this->indentText = str_repeat(' ', intval($indentation));
$this->subIndentText = $this->indentText . str_repeat(' ', intval($subIndentation));
}




public function printHeader(Formatter $formatter, FeatureNode $feature, OutlineNode $outline, array $results)
{
$this->scenarioPrinter->printHeader($formatter, $feature, $outline);

$this->printExamplesSteps($formatter, $outline, $outline->getSteps(), $results);
$this->printExamplesTableHeader($formatter->getOutputPrinter(), $outline->getExampleTable());
}




public function printFooter(Formatter $formatter, TestResult $result)
{
$formatter->getOutputPrinter()->writeln();
}









private function printExamplesSteps(Formatter $formatter, OutlineNode $outline, array $steps, array $results)
{
foreach ($steps as $step) {
$result = $results[$step->getLine()];

$this->stepPrinter->printStep($formatter, $outline, $step, $result);
}

$formatter->getOutputPrinter()->writeln();
}







private function printExamplesTableHeader(OutputPrinter $printer, ExampleTableNode $table)
{
$printer->writeln(sprintf('%s{+keyword}%s:{-keyword}', $this->indentText, $table->getKeyword()));

$rowNum = 0;
$wrapper = $this->getWrapperClosure();
$row = $table->getRowAsStringWithWrappedValues($rowNum, $wrapper);

$printer->writeln(sprintf('%s%s', $this->subIndentText, $row));
}






private function getWrapperClosure()
{
$style = $this->resultConverter->convertResultCodeToString(TestResult::SKIPPED);

return function ($col) use ($style) {
return sprintf('{+%s_param}%s{-%s_param}', $style, $col, $style);
};
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Pretty;

use Behat\Behat\Output\Node\Printer\Helper\WidthCalculator;
use Behat\Behat\Tester\Result\DefinedStepResult;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\OutputPrinter;






final class PrettyPathPrinter
{



private $widthCalculator;



private $basePath;







public function __construct(WidthCalculator $widthCalculator, $basePath)
{
$this->widthCalculator = $widthCalculator;
$this->basePath = $basePath;
}









public function printScenarioPath(Formatter $formatter, FeatureNode $feature, Scenario $scenario, $indentation)
{
$printer = $formatter->getOutputPrinter();

if (!$formatter->getParameter('paths')) {
$printer->writeln();

return;
}

$fileAndLine = sprintf('%s:%s', $this->relativizePaths($feature->getFile()), $scenario->getLine());
$headerWidth = $this->widthCalculator->calculateScenarioHeaderWidth($scenario, $indentation);
$scenarioWidth = $this->widthCalculator->calculateScenarioWidth($scenario, $indentation, 2);
$spacing = str_repeat(' ', max(0, $scenarioWidth - $headerWidth));

$printer->writeln(sprintf('%s {+comment}# %s{-comment}', $spacing, $fileAndLine));
}










public function printStepPath(
Formatter $formatter,
Scenario $scenario,
StepNode $step,
StepResult $result,
$indentation
) {
$printer = $formatter->getOutputPrinter();

if (!$result instanceof DefinedStepResult || !$result->getStepDefinition() || !$formatter->getParameter('paths')) {
$printer->writeln();

return;
}

$textWidth = $this->widthCalculator->calculateStepWidth($step, $indentation);
$scenarioWidth = $this->widthCalculator->calculateScenarioWidth($scenario, $indentation - 2, 2);

$this->printDefinedStepPath($printer, $result, $scenarioWidth, $textWidth);
}









private function printDefinedStepPath(OutputPrinter $printer, DefinedStepResult $result, $scenarioWidth, $stepWidth)
{
$path = $result->getStepDefinition()->getPath();
$spacing = str_repeat(' ', max(0, $scenarioWidth - $stepWidth));

$printer->writeln(sprintf('%s {+comment}# %s{-comment}', $spacing, $path));
}








private function relativizePaths($path)
{
if (!$this->basePath) {
return $path;
}

return str_replace($this->basePath . DIRECTORY_SEPARATOR, '', $path);
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Pretty;

use Behat\Behat\Output\Node\Printer\ScenarioPrinter;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Gherkin\Node\TaggedNodeInterface;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\OutputPrinter;
use Behat\Testwork\Tester\Result\TestResult;






final class PrettyScenarioPrinter implements ScenarioPrinter
{



private $pathPrinter;



private $indentText;



private $subIndentText;








public function __construct(PrettyPathPrinter $pathPrinter, $indentation = 2, $subIndentation = 2)
{
$this->pathPrinter = $pathPrinter;
$this->indentText = str_repeat(' ', intval($indentation));
$this->subIndentText = $this->indentText . str_repeat(' ', intval($subIndentation));
}




public function printHeader(Formatter $formatter, FeatureNode $feature, Scenario $scenario)
{
if ($scenario instanceof TaggedNodeInterface) {
$this->printTags($formatter->getOutputPrinter(), $scenario->getTags());
}

$this->printKeyword($formatter->getOutputPrinter(), $scenario->getKeyword());
$this->printTitle($formatter->getOutputPrinter(), $scenario->getTitle());
$this->pathPrinter->printScenarioPath($formatter, $feature, $scenario, mb_strlen($this->indentText, 'utf8'));
$this->printDescription($formatter->getOutputPrinter(), $scenario->getTitle());
}




public function printFooter(Formatter $formatter, TestResult $result)
{
$formatter->getOutputPrinter()->writeln();
}







private function printTags(OutputPrinter $printer, array $tags)
{
if (!count($tags)) {
return;
}

$tags = array_map(array($this, 'prependTagWithTagSign'), $tags);
$printer->writeln(sprintf('%s{+tag}%s{-tag}', $this->indentText, implode(' ', $tags)));
}







private function printKeyword(OutputPrinter $printer, $keyword)
{
$printer->write(sprintf('%s{+keyword}%s:{-keyword}', $this->indentText, $keyword));
}







private function printTitle(OutputPrinter $printer, $longTitle)
{
$description = explode("\n", $longTitle);
$title = array_shift($description);

if ('' !== $title) {
$printer->write(sprintf(' %s', $title));
}
}







private function printDescription(OutputPrinter $printer, $longTitle)
{
$lines = explode("\n", $longTitle);
array_shift($lines);

foreach ($lines as $line) {
$printer->writeln(sprintf('%s%s', $this->subIndentText, $line));
}
}








private function prependTagWithTagSign($tag)
{
return '@' . $tag;
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Pretty;

use Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter;
use Behat\Behat\Output\Node\Printer\SetupPrinter;
use Behat\Testwork\Call\CallResult;
use Behat\Testwork\Exception\ExceptionPresenter;
use Behat\Testwork\Hook\Tester\Setup\HookedSetup;
use Behat\Testwork\Hook\Tester\Setup\HookedTeardown;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\OutputPrinter;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Setup\Setup;
use Behat\Testwork\Tester\Setup\Teardown;






final class PrettySetupPrinter implements SetupPrinter
{



private $resultConverter;



private $exceptionPresenter;



private $indentText;



private $newlineBefore;



private $newlineAfter;










public function __construct(
ResultToStringConverter $resultConverter,
ExceptionPresenter $exceptionPresenter,
$indentation = 0,
$newlineBefore = false,
$newlineAfter = false
) {
$this->resultConverter = $resultConverter;
$this->exceptionPresenter = $exceptionPresenter;
$this->indentText = str_repeat(' ', intval($indentation));
$this->newlineBefore = $newlineBefore;
$this->newlineAfter = $newlineAfter;
}




public function printSetup(Formatter $formatter, Setup $setup)
{
if (!$setup instanceof HookedSetup) {
return;
}

foreach ($setup->getHookCallResults() as $callResult) {
$this->printSetupHookCallResult($formatter->getOutputPrinter(), $callResult);
}
}




public function printTeardown(Formatter $formatter, Teardown $teardown)
{
if (!$teardown instanceof HookedTeardown) {
return;
}

foreach ($teardown->getHookCallResults() as $callResult) {
$this->printTeardownHookCallResult($formatter->getOutputPrinter(), $callResult);
}
}







private function printSetupHookCallResult(OutputPrinter $printer, CallResult $callResult)
{
if (!$callResult->hasStdOut() && !$callResult->hasException()) {
return;
}

$resultCode = $callResult->hasException() ? TestResult::FAILED : TestResult::PASSED;
$style = $this->resultConverter->convertResultCodeToString($resultCode);
$hook = $callResult->getCall()->getCallee();
$path = $hook->getPath();

$printer->writeln(
sprintf('%s {+%s}@%s{-%s} {+comment}# %s{-comment}', $this->indentText, $style, $hook, $style, $path)
);

$printer->writeln(sprintf('%s', $this->indentText));

$this->printHookCallStdOut($printer, $callResult, $this->indentText);
$this->printHookCallException($printer, $callResult, $this->indentText);

if ($this->newlineBefore) {
$printer->writeln();
}
}







private function printTeardownHookCallResult(OutputPrinter $printer, CallResult $callResult)
{
if (!$callResult->hasStdOut() && !$callResult->hasException()) {
return;
}

$resultCode = $callResult->hasException() ? TestResult::FAILED : TestResult::PASSED;
$style = $this->resultConverter->convertResultCodeToString($resultCode);
$hook = $callResult->getCall()->getCallee();
$path = $hook->getPath();

$printer->writeln(sprintf('%s', $this->indentText));

$this->printHookCallStdOut($printer, $callResult, $this->indentText);
$this->printHookCallException($printer, $callResult, $this->indentText);

$printer->writeln(
sprintf('%s {+%s}@%s{-%s} {+comment}# %s{-comment}', $this->indentText, $style, $hook, $style, $path)
);

if ($this->newlineAfter) {
$printer->writeln();
}
}








private function printHookCallStdOut(OutputPrinter $printer, CallResult $callResult, $indentText)
{
if (!$callResult->hasStdOut()) {
return;
}

$pad = function ($line) use ($indentText) {
return sprintf(
'%s  {+stdout}%s{-stdout}', $indentText, $line
);
};

$printer->writeln(implode("\n", array_map($pad, explode("\n", $callResult->getStdOut()))));
$printer->writeln(sprintf('%s', $indentText));
}








private function printHookCallException(OutputPrinter $printer, CallResult $callResult, $indentText)
{
if (!$callResult->hasException()) {
return;
}

$pad = function ($l) use ($indentText) {
return sprintf(
'%s  {+exception}%s{-exception}', $indentText, $l
);
};

$exception = $this->exceptionPresenter->presentException($callResult->getException());
$printer->writeln(implode("\n", array_map($pad, explode("\n", $exception))));
$printer->writeln(sprintf('%s', $indentText));
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Pretty;

use Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter;
use Behat\Behat\Output\Node\Printer\Helper\StepTextPainter;
use Behat\Behat\Output\Node\Printer\StepPrinter;
use Behat\Behat\Tester\Result\DefinedStepResult;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\ArgumentInterface;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\OutputPrinter;
use Behat\Testwork\Tester\Result\IntegerTestResult;
use Behat\Testwork\Tester\Result\TestResult;






final class PrettySkippedStepPrinter implements StepPrinter
{



private $textPainter;



private $resultConverter;



private $pathPrinter;



private $indentText;



private $subIndentText;










public function __construct(
StepTextPainter $textPainter,
ResultToStringConverter $resultConverter,
PrettyPathPrinter $pathPrinter,
$indentation = 4,
$subIndentation = 2
) {
$this->textPainter = $textPainter;
$this->resultConverter = $resultConverter;
$this->pathPrinter = $pathPrinter;
$this->indentText = str_repeat(' ', intval($indentation));
$this->subIndentText = $this->indentText . str_repeat(' ', intval($subIndentation));
}




public function printStep(Formatter $formatter, Scenario $scenario, StepNode $step, StepResult $result)
{
$this->printText($formatter->getOutputPrinter(), $step->getKeyword(), $step->getText(), $result);
$this->pathPrinter->printStepPath($formatter, $scenario, $step, $result, mb_strlen($this->indentText, 'utf8'));
$this->printArguments($formatter, $step->getArguments());
}









private function printText(OutputPrinter $printer, $stepType, $stepText, StepResult $result)
{
$style = $this->resultConverter->convertResultCodeToString(TestResult::SKIPPED);

if ($result instanceof DefinedStepResult && $result->getStepDefinition()) {
$definition = $result->getStepDefinition();
$stepText = $this->textPainter->paintText(
$stepText, $definition, new IntegerTestResult(TestResult::SKIPPED)
);
}

$printer->write(sprintf('%s{+%s}%s %s{-%s}', $this->indentText, $style, $stepType, $stepText, $style));
}







private function printArguments(Formatter $formatter, array $arguments)
{
$style = $this->resultConverter->convertResultCodeToString(TestResult::SKIPPED);

foreach ($arguments as $argument) {
$text = $this->getArgumentString($argument, !$formatter->getParameter('multiline'));

$indentedText = implode("\n", array_map(array($this, 'subIndent'), explode("\n", $text)));
$formatter->getOutputPrinter()->writeln(sprintf('{+%s}%s{-%s}', $style, $indentedText, $style));
}
}









private function getArgumentString(ArgumentInterface $argument, $collapse = false)
{
if ($collapse) {
return '...';
}

if ($argument instanceof PyStringNode) {
$text = '"""' . "\n" . $argument . "\n" . '"""';

return $text;
}

return (string) $argument;
}








private function subIndent($text)
{
return $this->subIndentText . $text;
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Pretty;

use Behat\Behat\Output\Node\Printer\CounterPrinter;
use Behat\Behat\Output\Node\Printer\ListPrinter;
use Behat\Behat\Output\Node\Printer\StatisticsPrinter;
use Behat\Behat\Output\Statistics\Statistics;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Tester\Result\TestResult;






final class PrettyStatisticsPrinter implements StatisticsPrinter
{



private $counterPrinter;



private $listPrinter;







public function __construct(CounterPrinter $counterPrinter, ListPrinter $listPrinter)
{
$this->counterPrinter = $counterPrinter;
$this->listPrinter = $listPrinter;
}




public function printStatistics(Formatter $formatter, Statistics $statistics)
{
$printer = $formatter->getOutputPrinter();

$scenarioStats = $statistics->getSkippedScenarios();
$this->listPrinter->printScenariosList($printer, 'skipped_scenarios_title', TestResult::SKIPPED, $scenarioStats);

$scenarioStats = $statistics->getFailedScenarios();
$this->listPrinter->printScenariosList($printer, 'failed_scenarios_title', TestResult::FAILED, $scenarioStats);

$this->counterPrinter->printCounters($printer, 'scenarios_count', $statistics->getScenarioStatCounts());
$this->counterPrinter->printCounters($printer, 'steps_count', $statistics->getStepStatCounts());

if ($formatter->getParameter('timer')) {
$timer = $statistics->getTimer();
$memory = $statistics->getMemory();

$formatter->getOutputPrinter()->writeln(sprintf('%s (%s)', $timer, $memory));
}
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Pretty;

use Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter;
use Behat\Behat\Output\Node\Printer\Helper\StepTextPainter;
use Behat\Behat\Output\Node\Printer\StepPrinter;
use Behat\Behat\Tester\Result\DefinedStepResult;
use Behat\Behat\Tester\Result\ExecutedStepResult;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\ArgumentInterface;
use Behat\Gherkin\Node\PyStringNode;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Exception\ExceptionPresenter;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Output\Printer\OutputPrinter;
use Behat\Testwork\Tester\Result\ExceptionResult;






final class PrettyStepPrinter implements StepPrinter
{



private $textPainter;



private $resultConverter;



private $pathPrinter;



private $exceptionPresenter;



private $indentText;



private $subIndentText;











public function __construct(
StepTextPainter $textPainter,
ResultToStringConverter $resultConverter,
PrettyPathPrinter $pathPrinter,
ExceptionPresenter $exceptionPresenter,
$indentation = 4,
$subIndentation = 2
) {
$this->textPainter = $textPainter;
$this->resultConverter = $resultConverter;
$this->pathPrinter = $pathPrinter;
$this->exceptionPresenter = $exceptionPresenter;
$this->indentText = str_repeat(' ', intval($indentation));
$this->subIndentText = $this->indentText . str_repeat(' ', intval($subIndentation));
}




public function printStep(Formatter $formatter, Scenario $scenario, StepNode $step, StepResult $result)
{
$this->printText($formatter->getOutputPrinter(), $step->getKeyword(), $step->getText(), $result);
$this->pathPrinter->printStepPath($formatter, $scenario, $step, $result, mb_strlen($this->indentText, 'utf8'));
$this->printArguments($formatter, $step->getArguments(), $result);
$this->printStdOut($formatter->getOutputPrinter(), $result);
$this->printException($formatter->getOutputPrinter(), $result);
}









private function printText(OutputPrinter $printer, $stepType, $stepText, StepResult $result)
{
if ($result && $result instanceof DefinedStepResult && $result->getStepDefinition()) {
$definition = $result->getStepDefinition();
$stepText = $this->textPainter->paintText($stepText, $definition, $result);
}

$style = $this->resultConverter->convertResultToString($result);
$printer->write(sprintf('%s{+%s}%s %s{-%s}', $this->indentText, $style, $stepType, $stepText, $style));
}








private function printArguments(Formatter $formatter, array $arguments, StepResult $result)
{
$style = $this->resultConverter->convertResultToString($result);

foreach ($arguments as $argument) {
$text = $this->getArgumentString($argument, !$formatter->getParameter('multiline'));

$indentedText = implode("\n", array_map(array($this, 'subIndent'), explode("\n", $text)));
$formatter->getOutputPrinter()->writeln(sprintf('{+%s}%s{-%s}', $style, $indentedText, $style));
}
}







private function printStdOut(OutputPrinter $printer, StepResult $result)
{
if (!$result instanceof ExecutedStepResult || null === $result->getCallResult()->getStdOut()) {
return;
}

$callResult = $result->getCallResult();
$indentedText = $this->subIndentText;

$pad = function ($line) use ($indentedText) {
return sprintf(
'%s {+stdout}%s{-stdout}', $indentedText, $line
);
};

$printer->writeln(implode("\n", array_map($pad, explode("\n", $callResult->getStdOut()))));
}







private function printException(OutputPrinter $printer, StepResult $result)
{
$style = $this->resultConverter->convertResultToString($result);

if (!$result instanceof ExceptionResult || !$result->hasException()) {
return;
}

$text = $this->exceptionPresenter->presentException($result->getException());
$indentedText = implode("\n", array_map(array($this, 'subIndent'), explode("\n", $text)));
$printer->writeln(sprintf('{+%s}%s{-%s}', $style, $indentedText, $style));
}









private function getArgumentString(ArgumentInterface $argument, $collapse = false)
{
if ($collapse) {
return '...';
}

if ($argument instanceof PyStringNode) {
$text = '"""' . "\n" . $argument . "\n" . '"""';

return $text;
}

return (string) $argument;
}








private function subIndent($text)
{
return $this->subIndentText . $text;
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Progress;

use Behat\Behat\Output\Node\Printer\CounterPrinter;
use Behat\Behat\Output\Node\Printer\ListPrinter;
use Behat\Behat\Output\Node\Printer\StatisticsPrinter;
use Behat\Behat\Output\Statistics\Statistics;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Tester\Result\TestResult;






final class ProgressStatisticsPrinter implements StatisticsPrinter
{



private $counterPrinter;



private $listPrinter;







public function __construct(CounterPrinter $counterPrinter, ListPrinter $listPrinter)
{
$this->counterPrinter = $counterPrinter;
$this->listPrinter = $listPrinter;
}




public function printStatistics(Formatter $formatter, Statistics $statistics)
{
$printer = $formatter->getOutputPrinter();

$printer->writeln();
$printer->writeln();

$hookStats = $statistics->getFailedHookStats();
$this->listPrinter->printFailedHooksList($printer, 'failed_hooks_title', $hookStats);

$stepStats = $statistics->getFailedSteps();
$this->listPrinter->printStepList($printer, 'failed_steps_title', TestResult::FAILED, $stepStats);

$stepStats = $statistics->getPendingSteps();
$this->listPrinter->printStepList($printer, 'pending_steps_title', TestResult::PENDING, $stepStats);

$this->counterPrinter->printCounters($printer, 'scenarios_count', $statistics->getScenarioStatCounts());
$this->counterPrinter->printCounters($printer, 'steps_count', $statistics->getStepStatCounts());

if ($formatter->getParameter('timer')) {
$timer = $statistics->getTimer();
$memory = $statistics->getMemory();

$formatter->getOutputPrinter()->writeln(sprintf('%s (%s)', $timer, $memory));
}
}
}
<?php









namespace Behat\Behat\Output\Node\Printer\Progress;

use Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter;
use Behat\Behat\Output\Node\Printer\StepPrinter;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Tester\Result\TestResult;






final class ProgressStepPrinter implements StepPrinter
{



private $resultConverter;



private $stepsPrinted = 0;






public function __construct(ResultToStringConverter $resultConverter)
{
$this->resultConverter = $resultConverter;
}




public function printStep(Formatter $formatter, Scenario $scenario, StepNode $step, StepResult $result)
{
$printer = $formatter->getOutputPrinter();
$style = $this->resultConverter->convertResultToString($result);

switch ($result->getResultCode()) {
case TestResult::PASSED:
$printer->write("{+$style}.{-$style}");
break;
case TestResult::SKIPPED:
$printer->write("{+$style}-{-$style}");
break;
case TestResult::PENDING:
$printer->write("{+$style}P{-$style}");
break;
case StepResult::UNDEFINED:
$printer->write("{+$style}U{-$style}");
break;
case TestResult::FAILED:
$printer->write("{+$style}F{-$style}");
break;
}

if (++$this->stepsPrinted % 70 == 0) {
$printer->writeln(' ' . $this->stepsPrinted);
}
}
}
<?php









namespace Behat\Behat\Output\Node\Printer;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Tester\Result\TestResult;






interface ScenarioPrinter
{







public function printHeader(Formatter $formatter, FeatureNode $feature, Scenario $scenario);







public function printFooter(Formatter $formatter, TestResult $result);
}
<?php









namespace Behat\Behat\Output\Node\Printer;

use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Tester\Setup\Setup;
use Behat\Testwork\Tester\Setup\Teardown;






interface SetupPrinter
{






public function printSetup(Formatter $formatter, Setup $setup);







public function printTeardown(Formatter $formatter, Teardown $teardown);
}
<?php









namespace Behat\Behat\Output\Node\Printer;

use Behat\Behat\Output\Statistics\Statistics;
use Behat\Testwork\Output\Formatter;






interface StatisticsPrinter
{






public function printStatistics(Formatter $formatter, Statistics $statistics);
}
<?php









namespace Behat\Behat\Output\Node\Printer;

use Behat\Behat\Tester\Result\StepResult;
use Behat\Gherkin\Node\ScenarioLikeInterface as Scenario;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Output\Formatter;






interface StepPrinter
{








public function printStep(Formatter $formatter, Scenario $scenario, StepNode $step, StepResult $result);
}
<?php









namespace Behat\Behat\Output\Node\Printer;

use Behat\Testwork\Output\Formatter;
use Behat\Testwork\Suite\Suite;






interface SuitePrinter
{






public function printHeader(Formatter $formatter, Suite $suite);







public function printFooter(Formatter $formatter, Suite $suite);
}
<?php









namespace Behat\Behat\Output\Printer;

use Behat\Behat\Output\Printer\Formatter\ConsoleFormatter;
use Behat\Testwork\Output\Printer\Factory\ConsoleOutputFactory as BaseFactory;
use Symfony\Component\Console\Formatter\OutputFormatterStyle;






final class ConsoleOutputFactory extends BaseFactory
{



protected function createOutputFormatter()
{
$formatter = new ConsoleFormatter($this->isOutputDecorated());

foreach ($this->getDefaultStyles() as $name => $style) {
$formatter->setStyle($name, $style);
}

return $formatter;
}






private function getDefaultStyles()
{
return array(
'keyword' => new OutputFormatterStyle(null, null, array('bold')),
'stdout' => new OutputFormatterStyle(null, null, array()),
'exception' => new OutputFormatterStyle('red'),
'undefined' => new OutputFormatterStyle('yellow'),
'pending' => new OutputFormatterStyle('yellow'),
'pending_param' => new OutputFormatterStyle('yellow', null, array('bold')),
'failed' => new OutputFormatterStyle('red'),
'failed_param' => new OutputFormatterStyle('red', null, array('bold')),
'passed' => new OutputFormatterStyle('green'),
'passed_param' => new OutputFormatterStyle('green', null, array('bold')),
'skipped' => new OutputFormatterStyle('cyan'),
'skipped_param' => new OutputFormatterStyle('cyan', null, array('bold')),
'comment' => new OutputFormatterStyle('black'),
'tag' => new OutputFormatterStyle('cyan')
);
}
}
<?php









namespace Behat\Behat\Output\Printer\Formatter;

use Symfony\Component\Console\Formatter\OutputFormatter as BaseOutputFormatter;






final class ConsoleFormatter extends BaseOutputFormatter
{
const CUSTOM_PATTERN = '/{\+([a-z-_]+)}(.*?){\-\\1}/si';








public function format($message)
{
return preg_replace_callback(self::CUSTOM_PATTERN, array($this, 'replaceStyle'), $message);
}








private function replaceStyle($match)
{
if (!$this->isDecorated()) {
return $match[2];
}

if ($this->hasStyle($match[1])) {
$style = $this->getStyle($match[1]);
} else {
return $match[0];
}

return $style->apply($match[2]);
}
}
<?php









namespace Behat\Behat\Output\ServiceContainer\Formatter;

use Behat\Testwork\Exception\ServiceContainer\ExceptionExtension;
use Behat\Testwork\Output\ServiceContainer\Formatter\FormatterFactory;
use Behat\Testwork\Output\ServiceContainer\OutputExtension;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Definition;
use Symfony\Component\DependencyInjection\Reference;






final class JUnitFormatterFactory implements FormatterFactory
{



const ROOT_LISTENER_ID = 'output.node.listener.junit';
const RESULT_TO_STRING_CONVERTER_ID = 'output.node.printer.result_to_string';




public function buildFormatter(ContainerBuilder $container)
{
$this->loadRootNodeListener($container);
$this->loadPrinterHelpers($container);
$this->loadCorePrinters($container);
$this->loadFormatter($container);
}




public function processFormatter(ContainerBuilder $container)
{
}






private function loadPrinterHelpers(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter');
$container->setDefinition(self::RESULT_TO_STRING_CONVERTER_ID, $definition);
}






private function loadCorePrinters(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Node\Printer\JUnit\JUnitSuitePrinter', array(
new Reference('output.junit.statistics'),
));
$container->setDefinition('output.node.printer.junit.suite', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\JUnit\JUnitFeaturePrinter', array(
new Reference('output.junit.statistics'),
));
$container->setDefinition('output.node.printer.junit.feature', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\JUnit\JUnitScenarioPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference('output.node.listener.junit.outline'),
));
$container->setDefinition('output.node.printer.junit.scenario', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\JUnit\JUnitStepPrinter', array(
new Reference(ExceptionExtension::PRESENTER_ID),
));
$container->setDefinition('output.node.printer.junit.step', $definition);

$definition = new Definition(
'Behat\Behat\Output\Node\Printer\JUnit\JUnitSetupPrinter', array(
new Reference(ExceptionExtension::PRESENTER_ID),
)
);
$container->setDefinition('output.node.printer.junit.setup', $definition);
}






private function loadRootNodeListener(ContainerBuilder $container)
{

$definition = new Definition('Behat\Behat\Output\Node\EventListener\JUnit\JUnitOutlineStoreListener', array(
new Reference('output.node.printer.junit.suite')
)
);
$container->setDefinition('output.node.listener.junit.outline', $definition);


$definition = new Definition('Behat\Testwork\Output\Node\EventListener\ChainEventListener', array(
array(
new Reference('output.node.listener.junit.outline'),
new Definition('Behat\Behat\Output\Node\EventListener\JUnit\JUnitFeatureElementListener', array(
new Reference('output.node.printer.junit.feature'),
new Reference('output.node.printer.junit.scenario'),
new Reference('output.node.printer.junit.step'),
new Reference('output.node.printer.junit.setup'),
)),
),
));
$container->setDefinition(self::ROOT_LISTENER_ID, $definition);
}






private function loadFormatter(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Statistics\PhaseStatistics');
$container->setDefinition('output.junit.statistics', $definition);

$definition = new Definition('Behat\Testwork\Output\NodeEventListeningFormatter', array(
'junit',
'Outputs the failures in JUnit compatible files.',
array(
'timer' => true,
),
$this->createOutputPrinterDefinition(),
new Definition('Behat\Testwork\Output\Node\EventListener\ChainEventListener', array(
array(
new Reference(self::ROOT_LISTENER_ID),
new Definition('Behat\Behat\Output\Node\EventListener\Statistics\ScenarioStatsListener', array(
new Reference('output.junit.statistics')
)),
new Definition('Behat\Behat\Output\Node\EventListener\Statistics\StepStatsListener', array(
new Reference('output.junit.statistics'),
new Reference(ExceptionExtension::PRESENTER_ID)
)),
new Definition('Behat\Behat\Output\Node\EventListener\Statistics\HookStatsListener', array(
new Reference('output.junit.statistics'),
new Reference(ExceptionExtension::PRESENTER_ID)
)),
),
)),
));
$definition->addTag(OutputExtension::FORMATTER_TAG, array('priority' => 100));
$container->setDefinition(OutputExtension::FORMATTER_TAG . '.junit', $definition);
}






private function createOutputPrinterDefinition()
{
return new Definition('Behat\Testwork\Output\Printer\JUnitOutputPrinter', array(
new Definition('Behat\Testwork\Output\Printer\Factory\FilesystemOutputFactory'),
));
}
}
<?php









namespace Behat\Behat\Output\ServiceContainer\Formatter;

use Behat\Behat\Definition\ServiceContainer\DefinitionExtension;
use Behat\Behat\EventDispatcher\Event\BackgroundTested;
use Behat\Behat\EventDispatcher\Event\OutlineTested;
use Behat\Behat\EventDispatcher\Event\ScenarioTested;
use Behat\Testwork\Exception\ServiceContainer\ExceptionExtension;
use Behat\Testwork\Output\ServiceContainer\Formatter\FormatterFactory;
use Behat\Testwork\Output\ServiceContainer\OutputExtension;
use Behat\Testwork\ServiceContainer\ServiceProcessor;
use Behat\Testwork\Translator\ServiceContainer\TranslatorExtension;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Definition;
use Symfony\Component\DependencyInjection\Reference;






class PrettyFormatterFactory implements FormatterFactory
{



private $processor;




const ROOT_LISTENER_ID = 'output.node.listener.pretty';
const RESULT_TO_STRING_CONVERTER_ID = 'output.node.printer.result_to_string';




const ROOT_LISTENER_WRAPPER_TAG = 'output.node.listener.pretty.wrapper';






public function __construct(ServiceProcessor $processor = null)
{
$this->processor = $processor ? : new ServiceProcessor();
}




public function buildFormatter(ContainerBuilder $container)
{
$this->loadRootNodeListener($container);

$this->loadCorePrinters($container);
$this->loadTableOutlinePrinter($container);
$this->loadExpandedOutlinePrinter($container);
$this->loadHookPrinters($container);
$this->loadStatisticsPrinter($container);
$this->loadPrinterHelpers($container);

$this->loadFormatter($container);
}




public function processFormatter(ContainerBuilder $container)
{
$this->processListenerWrappers($container);
}






protected function loadRootNodeListener(ContainerBuilder $container)
{
$definition = new Definition('Behat\Testwork\Output\Node\EventListener\ChainEventListener', array(
array(
new Definition('Behat\Behat\Output\Node\EventListener\AST\SuiteListener', array(
new Reference('output.node.printer.pretty.suite_setup')
)),
new Definition('Behat\Behat\Output\Node\EventListener\AST\FeatureListener', array(
new Reference('output.node.printer.pretty.feature'),
new Reference('output.node.printer.pretty.feature_setup')
)),
$this->proxySiblingEvents(
BackgroundTested::BEFORE,
BackgroundTested::AFTER,
array(
new Definition('Behat\Behat\Output\Node\EventListener\AST\ScenarioNodeListener', array(
BackgroundTested::AFTER_SETUP,
BackgroundTested::AFTER,
new Reference('output.node.printer.pretty.scenario')
)),
new Definition('Behat\Behat\Output\Node\EventListener\AST\StepListener', array(
new Reference('output.node.printer.pretty.step'),
new Reference('output.node.printer.pretty.step_setup')
)),
)
),
$this->proxySiblingEvents(
ScenarioTested::BEFORE,
ScenarioTested::AFTER,
array(
new Definition('Behat\Behat\Output\Node\EventListener\AST\ScenarioNodeListener', array(
ScenarioTested::AFTER_SETUP,
ScenarioTested::AFTER,
new Reference('output.node.printer.pretty.scenario'),
new Reference('output.node.printer.pretty.scenario_setup')
)),
new Definition('Behat\Behat\Output\Node\EventListener\AST\StepListener', array(
new Reference('output.node.printer.pretty.step'),
new Reference('output.node.printer.pretty.step_setup')
)),
)
),
$this->proxySiblingEvents(
OutlineTested::BEFORE,
OutlineTested::AFTER,
array(
$this->proxyEventsIfParameterIsSet(
'expand',
false,
new Definition('Behat\Behat\Output\Node\EventListener\AST\OutlineTableListener', array(
new Reference('output.node.printer.pretty.outline_table'),
new Reference('output.node.printer.pretty.example_row'),
new Reference('output.node.printer.pretty.example_setup'),
new Reference('output.node.printer.pretty.example_step_setup')
))
),
$this->proxyEventsIfParameterIsSet(
'expand',
true,
new Definition('Behat\Behat\Output\Node\EventListener\AST\OutlineListener', array(
new Reference('output.node.printer.pretty.outline'),
new Reference('output.node.printer.pretty.example'),
new Reference('output.node.printer.pretty.example_step'),
new Reference('output.node.printer.pretty.example_setup'),
new Reference('output.node.printer.pretty.example_step_setup')
))
)
)
),
)
));
$container->setDefinition(self::ROOT_LISTENER_ID, $definition);
}






protected function loadFormatter(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Statistics\TotalStatistics');
$container->setDefinition('output.pretty.statistics', $definition);

$definition = new Definition('Behat\Testwork\Output\NodeEventListeningFormatter', array(
'pretty',
'Prints the feature as is.',
array(
'timer' => true,
'expand' => false,
'paths' => true,
'multiline' => true,
),
$this->createOutputPrinterDefinition(),
new Definition('Behat\Testwork\Output\Node\EventListener\ChainEventListener', array(
array(
$this->rearrangeBackgroundEvents(
new Reference(self::ROOT_LISTENER_ID)
),
new Definition('Behat\Behat\Output\Node\EventListener\Statistics\StatisticsListener', array(
new Reference('output.pretty.statistics'),
new Reference('output.node.printer.pretty.statistics')
)),
new Definition('Behat\Behat\Output\Node\EventListener\Statistics\ScenarioStatsListener', array(
new Reference('output.pretty.statistics')
)),
new Definition('Behat\Behat\Output\Node\EventListener\Statistics\StepStatsListener', array(
new Reference('output.pretty.statistics'),
new Reference(ExceptionExtension::PRESENTER_ID)
)),
)
)
)
));
$definition->addTag(OutputExtension::FORMATTER_TAG, array('priority' => 100));
$container->setDefinition(OutputExtension::FORMATTER_TAG . '.pretty', $definition);
}






protected function loadCorePrinters(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettyFeaturePrinter');
$container->setDefinition('output.node.printer.pretty.feature', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettyPathPrinter', array(
new Reference('output.node.printer.pretty.width_calculator'),
'%paths.base%'
));
$container->setDefinition('output.node.printer.pretty.path', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettyScenarioPrinter', array(
new Reference('output.node.printer.pretty.path'),
));
$container->setDefinition('output.node.printer.pretty.scenario', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettyStepPrinter', array(
new Reference('output.node.printer.pretty.step_text_painter'),
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference('output.node.printer.pretty.path'),
new Reference(ExceptionExtension::PRESENTER_ID)
));
$container->setDefinition('output.node.printer.pretty.step', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettySkippedStepPrinter', array(
new Reference('output.node.printer.pretty.step_text_painter'),
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference('output.node.printer.pretty.path'),
));
$container->setDefinition('output.node.printer.pretty.skipped_step', $definition);
}






protected function loadTableOutlinePrinter(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettyOutlineTablePrinter', array(
new Reference('output.node.printer.pretty.scenario'),
new Reference('output.node.printer.pretty.skipped_step'),
new Reference(self::RESULT_TO_STRING_CONVERTER_ID)
));
$container->setDefinition('output.node.printer.pretty.outline_table', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettyExampleRowPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference(ExceptionExtension::PRESENTER_ID)
));
$container->setDefinition('output.node.printer.pretty.example_row', $definition);
}






protected function loadExpandedOutlinePrinter(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettyOutlinePrinter', array(
new Reference('output.node.printer.pretty.scenario'),
new Reference('output.node.printer.pretty.skipped_step'),
new Reference(self::RESULT_TO_STRING_CONVERTER_ID)
));
$container->setDefinition('output.node.printer.pretty.outline', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettyExamplePrinter', array(
new Reference('output.node.printer.pretty.path'),
));
$container->setDefinition('output.node.printer.pretty.example', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettyStepPrinter', array(
new Reference('output.node.printer.pretty.step_text_painter'),
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference('output.node.printer.pretty.path'),
new Reference(ExceptionExtension::PRESENTER_ID),
8
));
$container->setDefinition('output.node.printer.pretty.example_step', $definition);
}






protected function loadHookPrinters(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettySetupPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference(ExceptionExtension::PRESENTER_ID),
0,
true,
true
));
$container->setDefinition('output.node.printer.pretty.suite_setup', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettySetupPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference(ExceptionExtension::PRESENTER_ID),
0,
false,
true
));
$container->setDefinition('output.node.printer.pretty.feature_setup', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettySetupPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference(ExceptionExtension::PRESENTER_ID),
2
));
$container->setDefinition('output.node.printer.pretty.scenario_setup', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettySetupPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference(ExceptionExtension::PRESENTER_ID),
4
));
$container->setDefinition('output.node.printer.pretty.step_setup', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettySetupPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference(ExceptionExtension::PRESENTER_ID),
8
));
$container->setDefinition('output.node.printer.pretty.example_step_setup', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettySetupPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference(ExceptionExtension::PRESENTER_ID),
6
));
$container->setDefinition('output.node.printer.pretty.example_setup', $definition);
}






protected function loadStatisticsPrinter(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Node\Printer\CounterPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference(TranslatorExtension::TRANSLATOR_ID),
));
$container->setDefinition('output.node.printer.counter', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\ListPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference(ExceptionExtension::PRESENTER_ID),
new Reference(TranslatorExtension::TRANSLATOR_ID),
'%paths.base%'
));
$container->setDefinition('output.node.printer.list', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Pretty\PrettyStatisticsPrinter', array(
new Reference('output.node.printer.counter'),
new Reference('output.node.printer.list')
));
$container->setDefinition('output.node.printer.pretty.statistics', $definition);
}






protected function loadPrinterHelpers(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Node\Printer\Helper\WidthCalculator');
$container->setDefinition('output.node.printer.pretty.width_calculator', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Helper\StepTextPainter', array(
new Reference(DefinitionExtension::PATTERN_TRANSFORMER_ID),
new Reference(self::RESULT_TO_STRING_CONVERTER_ID)
));
$container->setDefinition('output.node.printer.pretty.step_text_painter', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter');
$container->setDefinition(self::RESULT_TO_STRING_CONVERTER_ID, $definition);
}






protected function createOutputPrinterDefinition()
{
return new Definition('Behat\Testwork\Output\Printer\StreamOutputPrinter', array(
new Definition('Behat\Behat\Output\Printer\ConsoleOutputFactory'),
));
}








protected function rearrangeBackgroundEvents($listener)
{
return new Definition('Behat\Behat\Output\Node\EventListener\Flow\FirstBackgroundFiresFirstListener', array(
new Definition('Behat\Behat\Output\Node\EventListener\Flow\OnlyFirstBackgroundFiresListener', array(
$listener
))
));
}










protected function proxySiblingEvents($beforeEventName, $afterEventName, array $listeners)
{
return new Definition('Behat\Behat\Output\Node\EventListener\Flow\FireOnlySiblingsListener',
array(
$beforeEventName,
$afterEventName,
new Definition('Behat\Testwork\Output\Node\EventListener\ChainEventListener', array($listeners))
)
);
}










protected function proxyEventsIfParameterIsSet($name, $value, Definition $listener)
{
return new Definition('Behat\Testwork\Output\Node\EventListener\Flow\FireOnlyIfFormatterParameterListener',
array($name, $value, $listener)
);
}






protected function processListenerWrappers(ContainerBuilder $container)
{
$this->processor->processWrapperServices($container, self::ROOT_LISTENER_ID, self::ROOT_LISTENER_WRAPPER_TAG);
}
}
<?php









namespace Behat\Behat\Output\ServiceContainer\Formatter;

use Behat\Testwork\Exception\ServiceContainer\ExceptionExtension;
use Behat\Testwork\Output\ServiceContainer\Formatter\FormatterFactory;
use Behat\Testwork\Output\ServiceContainer\OutputExtension;
use Behat\Testwork\ServiceContainer\ServiceProcessor;
use Behat\Testwork\Translator\ServiceContainer\TranslatorExtension;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Definition;
use Symfony\Component\DependencyInjection\Reference;






class ProgressFormatterFactory implements FormatterFactory
{



private $processor;




const ROOT_LISTENER_ID = 'output.node.listener.progress';
const RESULT_TO_STRING_CONVERTER_ID = 'output.node.printer.result_to_string';




const ROOT_LISTENER_WRAPPER_TAG = 'output.node.listener.progress.wrapper';






public function __construct(ServiceProcessor $processor = null)
{
$this->processor = $processor ? : new ServiceProcessor();
}




public function buildFormatter(ContainerBuilder $container)
{
$this->loadRootNodeListener($container);
$this->loadCorePrinters($container);
$this->loadPrinterHelpers($container);
$this->loadFormatter($container);
}




public function processFormatter(ContainerBuilder $container)
{
$this->processListenerWrappers($container);
}






protected function loadRootNodeListener(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Node\EventListener\AST\StepListener', array(
new Reference('output.node.printer.progress.step')
));
$container->setDefinition(self::ROOT_LISTENER_ID, $definition);
}






protected function loadCorePrinters(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Node\Printer\CounterPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference(TranslatorExtension::TRANSLATOR_ID),
));
$container->setDefinition('output.node.printer.counter', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\ListPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID),
new Reference(ExceptionExtension::PRESENTER_ID),
new Reference(TranslatorExtension::TRANSLATOR_ID),
'%paths.base%'
));
$container->setDefinition('output.node.printer.list', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Progress\ProgressStepPrinter', array(
new Reference(self::RESULT_TO_STRING_CONVERTER_ID)
));
$container->setDefinition('output.node.printer.progress.step', $definition);

$definition = new Definition('Behat\Behat\Output\Node\Printer\Progress\ProgressStatisticsPrinter', array(
new Reference('output.node.printer.counter'),
new Reference('output.node.printer.list')
));
$container->setDefinition('output.node.printer.progress.statistics', $definition);
}






protected function loadPrinterHelpers(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Node\Printer\Helper\ResultToStringConverter');
$container->setDefinition(self::RESULT_TO_STRING_CONVERTER_ID, $definition);
}






protected function loadFormatter(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Output\Statistics\TotalStatistics');
$container->setDefinition('output.progress.statistics', $definition);

$definition = new Definition('Behat\Testwork\Output\NodeEventListeningFormatter', array(
'progress',
'Prints one character per step.',
array(
'timer' => true
),
$this->createOutputPrinterDefinition(),
new Definition('Behat\Testwork\Output\Node\EventListener\ChainEventListener', array(
array(
new Reference(self::ROOT_LISTENER_ID),
new Definition('Behat\Behat\Output\Node\EventListener\Statistics\StatisticsListener', array(
new Reference('output.progress.statistics'),
new Reference('output.node.printer.progress.statistics')
)),
new Definition('Behat\Behat\Output\Node\EventListener\Statistics\ScenarioStatsListener', array(
new Reference('output.progress.statistics')
)),
new Definition('Behat\Behat\Output\Node\EventListener\Statistics\StepStatsListener', array(
new Reference('output.progress.statistics'),
new Reference(ExceptionExtension::PRESENTER_ID)
)),
new Definition('Behat\Behat\Output\Node\EventListener\Statistics\HookStatsListener', array(
new Reference('output.progress.statistics'),
new Reference(ExceptionExtension::PRESENTER_ID)
)),
)
)
)
));
$definition->addTag(OutputExtension::FORMATTER_TAG, array('priority' => 100));
$container->setDefinition(OutputExtension::FORMATTER_TAG . '.progress', $definition);
}






protected function createOutputPrinterDefinition()
{
return new Definition('Behat\Testwork\Output\Printer\StreamOutputPrinter', array(
new Definition('Behat\Behat\Output\Printer\ConsoleOutputFactory'),
));
}






protected function processListenerWrappers(ContainerBuilder $container)
{
$this->processor->processWrapperServices($container, self::ROOT_LISTENER_ID, self::ROOT_LISTENER_WRAPPER_TAG);
}
}
<?php









namespace Behat\Behat\Output\Statistics;






final class HookStat
{



private $name;



private $path;



private $error;



private $stdOut;









public function __construct($name, $path, $error = null, $stdOut = null)
{
$this->name = $name;
$this->path = $path;
$this->error = $error;
$this->stdOut = $stdOut;
}




public function getName()
{
return $this->name;
}




public function isSuccessful()
{
return null === $this->error;
}






public function getStdOut()
{
return $this->stdOut;
}






public function getError()
{
return $this->error;
}






public function getPath()
{
return $this->path;
}
}
<?php









namespace Behat\Behat\Output\Statistics;

use Behat\Testwork\Counter\Timer;
use Behat\Testwork\Counter\Memory;









final class PhaseStatistics implements Statistics
{



private $statistics;

public function __construct()
{
$this->statistics = new TotalStatistics();
}




public function reset()
{
$this->statistics = new TotalStatistics();
}




public function startTimer()
{
$this->statistics->startTimer();
}




public function stopTimer()
{
$this->statistics->stopTimer();
}






public function getTimer()
{
return $this->statistics->getTimer();
}






public function getMemory()
{
return $this->statistics->getMemory();
}






public function registerScenarioStat(ScenarioStat $stat)
{
$this->statistics->registerScenarioStat($stat);
}






public function registerStepStat(StepStat $stat)
{
$this->statistics->registerStepStat($stat);
}






public function registerHookStat(HookStat $stat)
{
$this->statistics->registerHookStat($stat);
}






public function getScenarioStatCounts()
{
return $this->statistics->getScenarioStatCounts();
}






public function getSkippedScenarios()
{
return $this->statistics->getSkippedScenarios();
}






public function getFailedScenarios()
{
return $this->statistics->getFailedScenarios();
}






public function getStepStatCounts()
{
return $this->statistics->getStepStatCounts();
}






public function getFailedSteps()
{
return $this->statistics->getFailedSteps();
}






public function getPendingSteps()
{
return $this->statistics->getPendingSteps();
}






public function getFailedHookStats()
{
return $this->statistics->getFailedHookStats();
}
}
<?php









namespace Behat\Behat\Output\Statistics;






final class ScenarioStat
{



private $title;



private $path;



private $resultCode;








public function __construct($title, $path, $resultCode)
{
$this->title = $title;
$this->path = $path;
$this->resultCode = $resultCode;
}






public function getTitle()
{
return $this->title;
}






public function getPath()
{
return $this->path;
}






public function getResultCode()
{
return $this->resultCode;
}






public function __toString()
{
return $this->getPath();
}
}
<?php









namespace Behat\Behat\Output\Statistics;

use Behat\Testwork\Counter\Memory;
use Behat\Testwork\Counter\Timer;







interface Statistics
{



public function startTimer();




public function stopTimer();






public function getTimer();






public function getMemory();






public function registerScenarioStat(ScenarioStat $stat);






public function registerStepStat(StepStat $stat);






public function registerHookStat(HookStat $stat);






public function getScenarioStatCounts();






public function getSkippedScenarios();






public function getFailedScenarios();






public function getStepStatCounts();






public function getFailedSteps();






public function getPendingSteps();






public function getFailedHookStats();
}
<?php









namespace Behat\Behat\Output\Statistics;








class StepStat
{



private $text;



private $path;



private $resultCode;



private $error;



private $stdOut;










public function __construct($text, $path, $resultCode, $error = null, $stdOut = null)
{
$this->text = $text;
$this->path = $path;
$this->resultCode = $resultCode;
$this->error = $error;
$this->stdOut = $stdOut;
}






public function getText()
{
return $this->text;
}






public function getPath()
{
return $this->path;
}






public function getResultCode()
{
return $this->resultCode;
}






public function getError()
{
return $this->error;
}






public function getStdOut()
{
return $this->stdOut;
}






public function __toString()
{
return $this->getPath();
}
}
<?php









namespace Behat\Behat\Output\Statistics;






final class StepStatV2 extends StepStat
{



private $scenarioTitle;



private $scenarioPath;



private $stepText;



private $stepPath;



private $resultCode;



private $error;



private $stdOut;












public function __construct($scenarioTitle, $scenarioPath, $stepText, $stepPath, $resultCode, $error = null, $stdOut = null)
{
parent::__construct($stepText, $stepPath, $resultCode, $error, $stdOut);

$this->scenarioTitle = $scenarioTitle;
$this->scenarioPath = $scenarioPath;
$this->stepText = $stepText;
$this->stepPath = $stepPath;
$this->resultCode = $resultCode;
$this->error = $error;
$this->stdOut = $stdOut;
}






public function getScenarioText()
{
return $this->scenarioTitle;
}






public function getScenarioPath()
{
return $this->scenarioPath;
}






public function getStepText()
{
return $this->stepText;
}






public function getStepPath()
{
return $this->stepPath;
}






public function getResultCode()
{
return $this->resultCode;
}






public function getError()
{
return $this->error;
}






public function getStdOut()
{
return $this->stdOut;
}






public function __toString()
{
return $this->getPath();
}
}
<?php









namespace Behat\Behat\Output\Statistics;

use Behat\Behat\Tester\Result\StepResult;
use Behat\Testwork\Counter\Memory;
use Behat\Testwork\Counter\Timer;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Result\TestResults;






final class TotalStatistics implements Statistics
{



private $timer;



private $memory;



private $scenarioCounters = array();



private $stepCounters = array();



private $failedScenarioStats = array();



private $skippedScenarioStats = array();



private $failedStepStats = array();



private $pendingStepStats = array();



private $failedHookStats = array();




public function __construct()
{
$this->resetAllCounters();

$this->timer = new Timer();
$this->memory = new Memory();
}

public function resetAllCounters()
{
$this->scenarioCounters = $this->stepCounters = array(
TestResult::PASSED => 0,
TestResult::FAILED => 0,
StepResult::UNDEFINED => 0,
TestResult::PENDING => 0,
TestResult::SKIPPED => 0
);
}




public function startTimer()
{
$this->timer->start();
}




public function stopTimer()
{
$this->timer->stop();
}






public function getTimer()
{
return $this->timer;
}






public function getMemory()
{
return $this->memory;
}






public function registerScenarioStat(ScenarioStat $stat)
{
if (TestResults::NO_TESTS === $stat->getResultCode()) {
return;
}

$this->scenarioCounters[$stat->getResultCode()]++;

if (TestResult::FAILED === $stat->getResultCode()) {
$this->failedScenarioStats[] = $stat;
}

if (TestResult::SKIPPED === $stat->getResultCode()) {
$this->skippedScenarioStats[] = $stat;
}
}






public function registerStepStat(StepStat $stat)
{
$this->stepCounters[$stat->getResultCode()]++;

if (TestResult::FAILED === $stat->getResultCode()) {
$this->failedStepStats[] = $stat;
}

if (TestResult::PENDING === $stat->getResultCode()) {
$this->pendingStepStats[] = $stat;
}
}






public function registerHookStat(HookStat $stat)
{
if ($stat->isSuccessful()) {
return;
}

$this->failedHookStats[] = $stat;
}






public function getScenarioStatCounts()
{
return $this->scenarioCounters;
}






public function getSkippedScenarios()
{
return $this->skippedScenarioStats;
}






public function getFailedScenarios()
{
return $this->failedScenarioStats;
}






public function getStepStatCounts()
{
return $this->stepCounters;
}






public function getFailedSteps()
{
return $this->failedStepStats;
}






public function getPendingSteps()
{
return $this->pendingStepStats;
}






public function getFailedHookStats()
{
return $this->failedHookStats;
}
}
<?php









namespace Behat\Behat\Snippet;

use Behat\Behat\Context\Snippet\ContextSnippet;
use Behat\Gherkin\Node\StepNode;






final class AggregateSnippet
{



private $snippets;






public function __construct(array $snippets)
{
$this->snippets = $snippets;
}






public function getType()
{
return current($this->snippets)->getType();
}






public function getHash()
{
return current($this->snippets)->getHash();
}






public function getSnippet()
{
return current($this->snippets)->getSnippet();
}






public function getSteps()
{
return array_unique(
array_map(
function (Snippet $snippet) {
return $snippet->getStep();
},
$this->snippets
),
SORT_REGULAR
);
}






public function getTargets()
{
return array_unique(
array_map(
function (Snippet $snippet) {
return $snippet->getTarget();
},
$this->snippets
)
);
}






public function getUsedClasses()
{
if (empty($this->snippets)) {
return array();
}

return array_unique(
call_user_func_array(
'array_merge',
array_map(
function (Snippet $snippet) {
if (!$snippet instanceof ContextSnippet) {
return array();
}

return $snippet->getUsedClasses();
},
$this->snippets
)
)
);
}
}
<?php









namespace Behat\Behat\Snippet\Appender;

use Behat\Behat\Snippet\AggregateSnippet;
use Behat\Behat\Snippet\SnippetWriter;








interface SnippetAppender
{







public function supportsSnippet(AggregateSnippet $snippet);






public function appendSnippet(AggregateSnippet $snippet);
}
<?php









namespace Behat\Behat\Snippet\Cli;

use Behat\Behat\EventDispatcher\Event\AfterStepTested;
use Behat\Behat\EventDispatcher\Event\StepTested;
use Behat\Behat\Snippet\Printer\ConsoleSnippetPrinter;
use Behat\Behat\Snippet\SnippetRegistry;
use Behat\Behat\Snippet\SnippetWriter;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Testwork\Cli\Controller;
use Behat\Testwork\EventDispatcher\Event\ExerciseCompleted;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;






final class SnippetsController implements Controller
{



private $registry;



private $writer;



private $printer;



private $eventDispatcher;



private $output;









public function __construct(
SnippetRegistry $registry,
SnippetWriter $writer,
ConsoleSnippetPrinter $printer,
EventDispatcherInterface $eventDispatcher
) {
$this->registry = $registry;
$this->writer = $writer;
$this->printer = $printer;
$this->eventDispatcher = $eventDispatcher;
}






public function configure(Command $command)
{
$command
->addOption(
'--append-snippets', null, InputOption::VALUE_NONE,
"Appends snippets for undefined steps into main context."
)
->addOption(
'--no-snippets', null, InputOption::VALUE_NONE,
"Do not print snippets for undefined steps after stats."
);
}









public function execute(InputInterface $input, OutputInterface $output)
{
$this->eventDispatcher->addListener(StepTested::AFTER, array($this, 'registerUndefinedStep'), -999);
$this->output = $output;

if ($input->getOption('append-snippets')) {
$this->eventDispatcher->addListener(ExerciseCompleted::AFTER, array($this, 'appendAllSnippets'), -999);
}

if (!$input->getOption('no-snippets') && !$input->getOption('append-snippets')) {
$this->eventDispatcher->addListener(ExerciseCompleted::AFTER, array($this, 'printAllSnippets'), -999);
}

if (!$input->getOption('no-snippets')) {
$this->eventDispatcher->addListener(ExerciseCompleted::AFTER, array($this, 'printUndefinedSteps'), -995);
}
}






public function registerUndefinedStep(AfterStepTested $event)
{
if (StepResult::UNDEFINED === $event->getTestResult()->getResultCode()) {
$this->registry->registerUndefinedStep($event->getEnvironment(), $event->getStep());
}
}




public function appendAllSnippets()
{
$snippets = $this->registry->getSnippets();
count($snippets) && $this->output->writeln('');

$this->writer->appendSnippets($snippets);
}




public function printAllSnippets()
{
$snippets = $this->registry->getSnippets();
count($snippets) && $this->output->writeln('');

$this->writer->printSnippets($this->printer, $snippets);
}




public function printUndefinedSteps()
{
$undefined = $this->registry->getUndefinedSteps();
count($undefined) && $this->output->writeln('');

$this->writer->printUndefinedSteps($this->printer, $undefined);
}
}
<?php









namespace Behat\Behat\Snippet\Exception;

use Behat\Testwork\Environment\Environment;
use RuntimeException;






final class EnvironmentSnippetGenerationException extends RuntimeException implements SnippetException
{



private $environment;







public function __construct($message, Environment $environment)
{
$this->environment = $environment;

parent::__construct($message);
}






public function getEnvironment()
{
return $this->environment;
}
}
<?php









namespace Behat\Behat\Snippet\Exception;

use Behat\Testwork\Exception\TestworkException;






interface SnippetException extends TestworkException
{
}
<?php









namespace Behat\Behat\Snippet\Generator;

use Behat\Behat\Snippet\Snippet;
use Behat\Behat\Snippet\SnippetRegistry;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Environment\Environment;








interface SnippetGenerator
{








public function supportsEnvironmentAndStep(Environment $environment, StepNode $step);









public function generateSnippet(Environment $environment, StepNode $step);
}
<?php









namespace Behat\Behat\Snippet\Printer;

use Behat\Behat\Snippet\AggregateSnippet;
use Behat\Gherkin\Node\StepNode;
use Symfony\Component\Console\Formatter\OutputFormatterStyle;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Translation\TranslatorInterface;








class ConsoleSnippetPrinter implements SnippetPrinter
{



private $output;



private $translator;







public function __construct(OutputInterface $output, TranslatorInterface $translator)
{
$this->output = $output;
$this->translator = $translator;

$output->getFormatter()->setStyle('snippet_keyword', new OutputFormatterStyle(null, null, array('bold')));
$output->getFormatter()->setStyle('snippet_undefined', new OutputFormatterStyle('yellow'));
}







public function printSnippets($targetName, array $snippets)
{
$message = $this->translator->trans('snippet_proposal_title', array('%1%' => $targetName), 'output');

$this->output->writeln('--- ' . $message . PHP_EOL);

foreach ($snippets as $snippet) {
$this->output->writeln(sprintf('<snippet_undefined>%s</snippet_undefined>', $snippet->getSnippet()) . PHP_EOL);
}
}







public function printUndefinedSteps($suiteName, array $steps)
{
$message = $this->translator->trans('snippet_missing_title', array('%1%' => $suiteName), 'output');

$this->output->writeln('--- ' . $message . PHP_EOL);

foreach ($steps as $step) {
$this->output->writeln(sprintf('    <snippet_undefined>%s %s</snippet_undefined>', $step->getKeyword(), $step->getText()));
}

$this->output->writeln('');
}
}
<?php









namespace Behat\Behat\Snippet\Printer;

use Behat\Behat\Snippet\AggregateSnippet;
use Behat\Gherkin\Node\StepNode;






interface SnippetPrinter
{






public function printSnippets($targetName, array $snippets);







public function printUndefinedSteps($suiteName, array $steps);
}
<?php









namespace Behat\Behat\Snippet\ServiceContainer;

use Behat\Testwork\Cli\ServiceContainer\CliExtension;
use Behat\Testwork\EventDispatcher\ServiceContainer\EventDispatcherExtension;
use Behat\Testwork\ServiceContainer\Extension;
use Behat\Testwork\ServiceContainer\ExtensionManager;
use Behat\Testwork\ServiceContainer\ServiceProcessor;
use Behat\Testwork\Translator\ServiceContainer\TranslatorExtension;
use Symfony\Component\Config\Definition\Builder\ArrayNodeDefinition;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Definition;
use Symfony\Component\DependencyInjection\Reference;






class SnippetExtension implements Extension
{



const REGISTRY_ID = 'snippet.registry';
const WRITER_ID = 'snippet.writer';




const GENERATOR_TAG = 'snippet.generator';
const APPENDER_TAG = 'snippet.appender';




private $processor;






public function __construct(ServiceProcessor $processor = null)
{
$this->processor = $processor ? : new ServiceProcessor();
}




public function getConfigKey()
{
return 'snippets';
}




public function initialize(ExtensionManager $extensionManager)
{
}




public function configure(ArrayNodeDefinition $builder)
{
}




public function load(ContainerBuilder $container, array $config)
{
$this->loadController($container);
$this->loadRegistry($container);
$this->loadWriter($container);
}




public function process(ContainerBuilder $container)
{
$this->processGenerators($container);
$this->processAppenders($container);
}




protected function loadController(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Snippet\Printer\ConsoleSnippetPrinter', array(
new Reference(CliExtension::OUTPUT_ID),
new Reference(TranslatorExtension::TRANSLATOR_ID)
));
$container->setDefinition('snippet.printer', $definition);

$definition = new Definition('Behat\Behat\Snippet\Cli\SnippetsController', array(
new Reference(self::REGISTRY_ID),
new Reference(self::WRITER_ID),
new Reference('snippet.printer'),
new Reference(EventDispatcherExtension::DISPATCHER_ID)
));
$definition->addTag(CliExtension::CONTROLLER_TAG, array('priority' => 400));
$container->setDefinition(CliExtension::CONTROLLER_TAG . '.snippet', $definition);
}




protected function loadRegistry(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Snippet\SnippetRegistry');
$container->setDefinition(self::REGISTRY_ID, $definition);
}




protected function loadWriter(ContainerBuilder $container)
{
$definition = new Definition('Behat\Behat\Snippet\SnippetWriter');
$container->setDefinition(self::WRITER_ID, $definition);
}




protected function processGenerators(ContainerBuilder $container)
{
$references = $this->processor->findAndSortTaggedServices($container, self::GENERATOR_TAG);
$definition = $container->getDefinition(self::REGISTRY_ID);

foreach ($references as $reference) {
$definition->addMethodCall('registerSnippetGenerator', array($reference));
}
}




protected function processAppenders(ContainerBuilder $container)
{
$references = $this->processor->findAndSortTaggedServices($container, self::APPENDER_TAG);
$definition = $container->getDefinition(self::WRITER_ID);

foreach ($references as $reference) {
$definition->addMethodCall('registerSnippetAppender', array($reference));
}
}
}
<?php









namespace Behat\Behat\Snippet;

use Behat\Gherkin\Node\StepNode;






interface Snippet
{





public function getType();






public function getHash();






public function getSnippet();






public function getStep();






public function getTarget();
}
<?php









namespace Behat\Behat\Snippet;

use Behat\Behat\Snippet\Generator\SnippetGenerator;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Environment\Environment;






final class SnippetRegistry implements SnippetRepository
{



private $generators = array();



private $undefinedSteps = array();



private $snippets = array();



private $snippetsGenerated = false;






public function registerSnippetGenerator(SnippetGenerator $generator)
{
$this->generators[] = $generator;
$this->snippetsGenerated = false;
}









public function registerUndefinedStep(Environment $environment, StepNode $step)
{
$this->undefinedSteps[] = new UndefinedStep($environment, $step);
$this->snippetsGenerated = false;
}






public function getSnippets()
{
$this->generateSnippets();

return $this->snippets;
}






public function getUndefinedSteps()
{
$this->generateSnippets();

return $this->undefinedSteps;
}




private function generateSnippets()
{
if ($this->snippetsGenerated) {
return null;
}

$snippetsSet = array();
foreach ($this->undefinedSteps as $i => $undefinedStep) {
$snippet = $this->generateSnippet($undefinedStep->getEnvironment(), $undefinedStep->getStep());

if (!$snippet) {
continue;
}

if (!isset($snippetsSet[$snippet->getHash()])) {
$snippetsSet[$snippet->getHash()] = array();
}

$snippetsSet[$snippet->getHash()][] = $snippet;
unset($this->undefinedSteps[$i]);
}

$this->snippets = array_values(
array_map(
function (array $snippets) {
return new AggregateSnippet($snippets);
},
$snippetsSet
)
);
$this->undefinedSteps = array_values($this->undefinedSteps);
$this->snippetsGenerated = true;
}







private function generateSnippet(Environment $environment, StepNode $step)
{
foreach ($this->generators as $generator) {
if ($generator->supportsEnvironmentAndStep($environment, $step)) {
return $generator->generateSnippet($environment, $step);
}
}

return null;
}
}
<?php









namespace Behat\Behat\Snippet;






interface SnippetRepository
{





public function getSnippets();






public function getUndefinedSteps();
}
<?php









namespace Behat\Behat\Snippet;

use Behat\Behat\Snippet\Appender\SnippetAppender;
use Behat\Behat\Snippet\Printer\SnippetPrinter;






final class SnippetWriter
{



private $appenders = array();






public function registerSnippetAppender(SnippetAppender $appender)
{
$this->appenders[] = $appender;
}






public function appendSnippets(array $snippets)
{
foreach ($snippets as $snippet) {
$this->appendSnippet($snippet);
}
}







public function printSnippets(SnippetPrinter $printer, array $snippets)
{
$printableSnippets = array();
foreach ($snippets as $snippet) {
foreach ($snippet->getTargets() as $target) {
$targetSnippets = array();

if (isset($printableSnippets[$target])) {
$targetSnippets = $printableSnippets[$target];
}

$targetSnippets[] = $snippet;
$printableSnippets[$target] = $targetSnippets;
}
}

foreach ($printableSnippets as $target => $targetSnippets) {
$printer->printSnippets($target, $targetSnippets);
}
}







public function printUndefinedSteps(SnippetPrinter $printer, array $undefinedSteps)
{
$printableSteps = array();
foreach ($undefinedSteps as $undefinedStep) {
$suiteName = $undefinedStep->getEnvironment()->getSuite()->getName();
$step = $undefinedStep->getStep();

if (!isset($printableSteps[$suiteName])) {
$printableSteps[$suiteName] = array();
}

$printableSteps[$suiteName][$step->getText()] = $step;
}

foreach ($printableSteps as $suiteName => $steps) {
$printer->printUndefinedSteps($suiteName, array_values($steps));
}
}






private function appendSnippet(AggregateSnippet $snippet)
{
foreach ($this->appenders as $appender) {
if (!$appender->supportsSnippet($snippet)) {
continue;
}

$appender->appendSnippet($snippet);
}
}
}
<?php









namespace Behat\Behat\Snippet;

use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Environment\Environment;






final class UndefinedStep
{



private $environment;



private $step;







public function __construct(Environment $environment, StepNode $step)
{
$this->environment = $environment;
$this->step = $step;
}






public function getEnvironment()
{
return $this->environment;
}






public function getStep()
{
return $this->step;
}
}
<?php









namespace Behat\Behat\Tester;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Setup\Setup;
use Behat\Testwork\Tester\Setup\Teardown;






interface BackgroundTester
{









public function setUp(Environment $env, FeatureNode $feature, $skip);










public function test(Environment $env, FeatureNode $feature, $skip);











public function tearDown(Environment $env, FeatureNode $feature, $skip, TestResult $result);
}
<?php









namespace Behat\Behat\Tester\Cli;

use Behat\Behat\EventDispatcher\Event\AfterScenarioTested;
use Behat\Behat\EventDispatcher\Event\ExampleTested;
use Behat\Behat\EventDispatcher\Event\ScenarioTested;
use Behat\Testwork\Cli\Controller;
use Behat\Testwork\EventDispatcher\Event\ExerciseCompleted;
use Behat\Testwork\Tester\Result\TestResult;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;






final class RerunController implements Controller
{



private $eventDispatcher;



private $cachePath;



private $key;



private $lines = array();



private $basepath;








public function __construct(EventDispatcherInterface $eventDispatcher, $cachePath, $basepath)
{
$this->eventDispatcher = $eventDispatcher;
$this->cachePath = null !== $cachePath ? rtrim($cachePath, DIRECTORY_SEPARATOR) : null;
$this->basepath = $basepath;
}






public function configure(Command $command)
{
$command->addOption('--rerun', null, InputOption::VALUE_NONE,
'Re-run scenarios that failed during last execution.'
);
}









public function execute(InputInterface $input, OutputInterface $output)
{
$this->eventDispatcher->addListener(ScenarioTested::AFTER, array($this, 'collectFailedScenario'), -50);
$this->eventDispatcher->addListener(ExampleTested::AFTER, array($this, 'collectFailedScenario'), -50);
$this->eventDispatcher->addListener(ExerciseCompleted::AFTER, array($this, 'writeCache'), -50);

$this->key = $this->generateKey($input);

if (!$input->getOption('rerun')) {
return;
}

if (!$this->getFileName() || !file_exists($this->getFileName())) {
return;
}

$input->setArgument('paths', $this->getFileName());
}






public function collectFailedScenario(AfterScenarioTested $event)
{
if (!$this->getFileName()) {
return;
}

if ($event->getTestResult()->getResultCode() !== TestResult::FAILED) {
return;
}

$feature = $event->getFeature();
$scenario = $event->getScenario();
$suitename = $event->getSuite()->getName();

$this->lines[$suitename][] = $feature->getFile() . ':' . $scenario->getLine();
}




public function writeCache()
{
if (!$this->getFileName()) {
return;
}

if (file_exists($this->getFileName())) {
unlink($this->getFileName());
}

if (0 === count($this->lines)) {
return;
}

file_put_contents($this->getFileName(), json_encode($this->lines));
}








private function generateKey(InputInterface $input)
{
return md5(
$input->getParameterOption(array('--profile', '-p')) .
$input->getOption('suite') .
implode(' ', $input->getOption('name')) .
implode(' ', $input->getOption('tags')) .
$input->getOption('role') .
$input->getArgument('paths') .
$this->basepath
);
}






private function getFileName()
{
if (null === $this->cachePath || null === $this->key) {
return null;
}

if (!is_dir($this->cachePath)) {
mkdir($this->cachePath, 0777);
}

return $this->cachePath . DIRECTORY_SEPARATOR . $this->key . '.rerun';
}
}
<?php









namespace Behat\Behat\Tester\Exception;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Exception\TestworkException;
use RuntimeException;






final class FeatureHasNoBackgroundException extends RuntimeException implements TestworkException
{



private $feature;







public function __construct($message, FeatureNode $feature)
{
$this->feature = $feature;

parent::__construct($message);
}






public function getFeature()
{
return $this->feature;
}
}
<?php









namespace Behat\Behat\Tester\Exception;

use Behat\Testwork\Tester\Exception\TesterException;
use RuntimeException;






final class PendingException extends RuntimeException implements TesterException
{





public function __construct($text = 'TODO: write pending definition')
{
parent::__construct($text);
}
}
<?php









namespace Behat\Behat\Tester\Exception\Stringer;

use Behat\Behat\Tester\Exception\PendingException;
use Behat\Testwork\Exception\Stringer\ExceptionStringer;
use Exception;






class PendingExceptionStringer implements ExceptionStringer
{



public function supportsException(Exception $exception)
{
return $exception instanceof PendingException;
}




public function stringException(Exception $exception, $verbosity)
{
return trim($exception->getMessage());
}
}
<?php









namespace Behat\Behat\Tester;

use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Setup\Setup;
use Behat\Testwork\Tester\Setup\Teardown;






interface OutlineTester
{










public function setUp(Environment $env, FeatureNode $feature, OutlineNode $outline, $skip);











public function test(Environment $env, FeatureNode $feature, OutlineNode $outline, $skip);












public function tearDown(Environment $env, FeatureNode $feature, OutlineNode $outline, $skip, TestResult $result);
}
<?php









namespace Behat\Behat\Tester\Result;

use Behat\Behat\Definition\Definition;






interface DefinedStepResult extends StepResult
{





public function getStepDefinition();
}
<?php









namespace Behat\Behat\Tester\Result;

use Behat\Behat\Definition\SearchResult;
use Behat\Behat\Tester\Exception\PendingException;
use Behat\Testwork\Call\CallResult;
use Behat\Testwork\Tester\Result\ExceptionResult;






final class ExecutedStepResult implements StepResult, DefinedStepResult, ExceptionResult
{



private $searchResult;



private $callResult;







public function __construct(SearchResult $searchResult, CallResult $callResult)
{
$this->searchResult = $searchResult;
$this->callResult = $callResult;
}






public function getSearchResult()
{
return $this->searchResult;
}






public function getCallResult()
{
return $this->callResult;
}




public function getStepDefinition()
{
return $this->searchResult->getMatchedDefinition();
}




public function hasException()
{
return null !== $this->getException();
}




public function getException()
{
return $this->callResult->getException();
}




public function getResultCode()
{
if ($this->callResult->hasException() && $this->callResult->getException() instanceof PendingException) {
return self::PENDING;
}

if ($this->callResult->hasException()) {
return self::FAILED;
}

return self::PASSED;
}




public function isPassed()
{
return self::PASSED == $this->getResultCode();
}
}
<?php









namespace Behat\Behat\Tester\Result;

use Behat\Behat\Definition\Exception\SearchException;
use Behat\Testwork\Tester\Result\ExceptionResult;






final class FailedStepSearchResult implements StepResult, ExceptionResult
{



private $searchException;






public function __construct(SearchException $searchException)
{
$this->searchException = $searchException;
}




public function hasException()
{
return true;
}




public function getException()
{
return $this->searchException;
}




public function isPassed()
{
return false;
}




public function getResultCode()
{
return self::FAILED;
}
}
<?php









namespace Behat\Behat\Tester\Result;

use Behat\Behat\Definition\SearchResult;






final class SkippedStepResult implements StepResult, DefinedStepResult
{



private $searchResult;






public function __construct(SearchResult $searchResult)
{
$this->searchResult = $searchResult;
}






public function getSearchResult()
{
return $this->searchResult;
}




public function getStepDefinition()
{
return $this->searchResult->getMatchedDefinition();
}




public function isPassed()
{
return false;
}




public function getResultCode()
{
return self::SKIPPED;
}
}
<?php









namespace Behat\Behat\Tester\Result;

use Behat\Testwork\Tester\Result\TestResult;






interface StepResult extends TestResult
{
const UNDEFINED = 30;
}
<?php









namespace Behat\Behat\Tester\Result;






final class UndefinedStepResult implements StepResult
{



public function isPassed()
{
return false;
}




public function getResultCode()
{
return self::UNDEFINED;
}
}
<?php









namespace Behat\Behat\Tester\Runtime;

use Behat\Behat\Tester\ScenarioTester;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface as Scenario;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Environment\EnvironmentManager;
use Behat\Testwork\Tester\Result\IntegerTestResult;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Result\TestWithSetupResult;
use Behat\Testwork\Tester\Setup\SuccessfulSetup;
use Behat\Testwork\Tester\Setup\SuccessfulTeardown;






final class IsolatingScenarioTester implements ScenarioTester
{



private $decoratedTester;



private $envManager;







public function __construct(ScenarioTester $decoratedTester, EnvironmentManager $envManager)
{
$this->decoratedTester = $decoratedTester;
$this->envManager = $envManager;
}




public function setUp(Environment $env, FeatureNode $feature, Scenario $scenario, $skip)
{
return new SuccessfulSetup();
}




public function test(Environment $env, FeatureNode $feature, Scenario $scenario, $skip)
{
$isolatedEnvironment = $this->envManager->isolateEnvironment($env, $scenario);

$setup = $this->decoratedTester->setUp($isolatedEnvironment, $feature, $scenario, $skip);
$localSkip = !$setup->isSuccessful() || $skip;
$testResult = $this->decoratedTester->test($isolatedEnvironment, $feature, $scenario, $localSkip);
$teardown = $this->decoratedTester->tearDown($isolatedEnvironment, $feature, $scenario, $localSkip, $testResult);

$integerResult = new IntegerTestResult($testResult->getResultCode());

return new TestWithSetupResult($setup, $integerResult, $teardown);
}




public function tearDown(Environment $env, FeatureNode $feature, Scenario $scenario, $skip, TestResult $result)
{
return new SuccessfulTeardown();
}
}
<?php









namespace Behat\Behat\Tester\Runtime;

use Behat\Behat\Tester\BackgroundTester;
use Behat\Behat\Tester\Exception\FeatureHasNoBackgroundException;
use Behat\Behat\Tester\StepContainerTester;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Tester\Result\IntegerTestResult;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Result\TestResults;
use Behat\Testwork\Tester\Setup\SuccessfulSetup;
use Behat\Testwork\Tester\Setup\SuccessfulTeardown;






final class RuntimeBackgroundTester implements BackgroundTester
{



private $containerTester;






public function __construct(StepContainerTester $containerTester)
{
$this->containerTester = $containerTester;
}




public function setUp(Environment $env, FeatureNode $feature, $skip)
{
return new SuccessfulSetup();
}




public function test(Environment $env, FeatureNode $feature, $skip)
{
$background = $feature->getBackground();

if (null === $background) {
throw new FeatureHasNoBackgroundException(sprintf(
'Feature `%s` has no background that could be tested.',
$feature->getFile()
), $feature);
}

if (!$background->hasSteps()) {
return new IntegerTestResult(TestResult::PASSED);
}

$results = $this->containerTester->test($env, $feature, $background, $skip);

return new TestResults($results);
}




public function tearDown(Environment $env, FeatureNode $feature, $skip, TestResult $result)
{
return new SuccessfulTeardown();
}
}
<?php









namespace Behat\Behat\Tester\Runtime;

use Behat\Behat\Tester\OutlineTester;
use Behat\Behat\Tester\ScenarioTester;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Environment\EnvironmentManager;
use Behat\Testwork\Tester\Result\IntegerTestResult;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Result\TestResults;
use Behat\Testwork\Tester\Result\TestWithSetupResult;
use Behat\Testwork\Tester\Setup\SuccessfulSetup;
use Behat\Testwork\Tester\Setup\SuccessfulTeardown;
use Behat\Testwork\Tester\SpecificationTester;






final class RuntimeFeatureTester implements SpecificationTester
{



private $scenarioTester;



private $outlineTester;



private $envManager;










public function __construct(
ScenarioTester $scenarioTester,
OutlineTester $outlineTester,
EnvironmentManager $envManager
) {
$this->scenarioTester = $scenarioTester;
$this->outlineTester = $outlineTester;
$this->envManager = $envManager;
}




public function setUp(Environment $env, $spec, $skip)
{
return new SuccessfulSetup();
}




public function test(Environment $env, $feature, $skip = false)
{
$results = array();
foreach ($feature->getScenarios() as $scenario) {
$tester = $scenario instanceof OutlineNode ? $this->outlineTester : $this->scenarioTester;

$setup = $tester->setUp($env, $feature, $scenario, $skip);
$localSkip = !$setup->isSuccessful() || $skip;
$testResult = $tester->test($env, $feature, $scenario, $localSkip);
$teardown = $tester->tearDown($env, $feature, $scenario, $localSkip, $testResult);

$integerResult = new IntegerTestResult($testResult->getResultCode());
$results[] = new TestWithSetupResult($setup, $integerResult, $teardown);
}

return new TestResults($results);
}




public function tearDown(Environment $env, $spec, $skip, TestResult $result)
{
return new SuccessfulTeardown();
}
}
<?php









namespace Behat\Behat\Tester\Runtime;

use Behat\Behat\Tester\OutlineTester;
use Behat\Behat\Tester\ScenarioTester;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\OutlineNode;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Tester\Result\IntegerTestResult;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Result\TestResults;
use Behat\Testwork\Tester\Result\TestWithSetupResult;
use Behat\Testwork\Tester\Setup\SuccessfulSetup;
use Behat\Testwork\Tester\Setup\SuccessfulTeardown;






final class RuntimeOutlineTester implements OutlineTester
{



private $scenarioTester;






public function __construct(ScenarioTester $scenarioTester)
{
$this->scenarioTester = $scenarioTester;
}




public function setUp(Environment $env, FeatureNode $feature, OutlineNode $outline, $skip)
{
return new SuccessfulSetup();
}




public function test(Environment $env, FeatureNode $feature, OutlineNode $outline, $skip = false)
{
$results = array();
foreach ($outline->getExamples() as $example) {
$setup = $this->scenarioTester->setUp($env, $feature, $example, $skip);
$localSkip = !$setup->isSuccessful() || $skip;
$testResult = $this->scenarioTester->test($env, $feature, $example, $localSkip);
$teardown = $this->scenarioTester->tearDown($env, $feature, $example, $localSkip, $testResult);

$integerResult = new IntegerTestResult($testResult->getResultCode());
$results[] = new TestWithSetupResult($setup, $integerResult, $teardown);
}

return new TestResults($results);
}




public function tearDown(Environment $env, FeatureNode $feature, OutlineNode $outline, $skip, TestResult $result)
{
return new SuccessfulTeardown();
}
}
<?php









namespace Behat\Behat\Tester\Runtime;

use Behat\Behat\Tester\BackgroundTester;
use Behat\Behat\Tester\StepContainerTester;
use Behat\Behat\Tester\ScenarioTester;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\ScenarioInterface as Scenario;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Tester\Result\IntegerTestResult;
use Behat\Testwork\Tester\Result\TestResult;
use Behat\Testwork\Tester\Result\TestResults;
use Behat\Testwork\Tester\Result\TestWithSetupResult;
use Behat\Testwork\Tester\Setup\SuccessfulSetup;
use Behat\Testwork\Tester\Setup\SuccessfulTeardown;






final class RuntimeScenarioTester implements ScenarioTester
{



private $containerTester;



private $backgroundTester;







public function __construct(StepContainerTester $containerTester, BackgroundTester $backgroundTester)
{
$this->containerTester = $containerTester;
$this->backgroundTester = $backgroundTester;
}




public function setUp(Environment $env, FeatureNode $feature, Scenario $example, $skip)
{
return new SuccessfulSetup();
}




public function test(Environment $env, FeatureNode $feature, Scenario $scenario, $skip = false)
{
$results = array();

if ($feature->hasBackground()) {
$backgroundResult = $this->testBackground($env, $feature, $skip);
$skip = !$backgroundResult->isPassed() || $skip;

$results[] = $backgroundResult;
}

$results = array_merge($results, $this->containerTester->test($env, $feature, $scenario, $skip));

return new TestResults($results);
}




public function tearDown(Environment $env, FeatureNode $feature, Scenario $scenario, $skip, TestResult $result)
{
return new SuccessfulTeardown();
}










private function testBackground(Environment $env, FeatureNode $feature, $skip)
{
$setup = $this->backgroundTester->setUp($env, $feature, $skip);
$skipSetup = !$setup->isSuccessful() || $skip;
$testResult = $this->backgroundTester->test($env, $feature, $skipSetup);
$teardown = $this->backgroundTester->tearDown($env, $feature, $skipSetup, $testResult);

$integerResult = new IntegerTestResult($testResult->getResultCode());

return new TestWithSetupResult($setup, $integerResult, $teardown);
}
}
<?php









namespace Behat\Behat\Tester\Runtime;

use Behat\Behat\Definition\Call\DefinitionCall;
use Behat\Behat\Definition\DefinitionFinder;
use Behat\Behat\Definition\Exception\SearchException;
use Behat\Behat\Definition\SearchResult;
use Behat\Behat\Tester\Result\ExecutedStepResult;
use Behat\Behat\Tester\Result\FailedStepSearchResult;
use Behat\Behat\Tester\Result\SkippedStepResult;
use Behat\Behat\Tester\Result\StepResult;
use Behat\Behat\Tester\Result\UndefinedStepResult;
use Behat\Behat\Tester\StepTester;
use Behat\Gherkin\Node\FeatureNode;
use Behat\Gherkin\Node\StepNode;
use Behat\Testwork\Call\CallCenter;
use Behat\Testwork\Environment\Environment;
use Behat\Testwork\Tester\Setup\SuccessfulSetup;
use Behat\Testwork\Tester\Setup\SuccessfulTeardown;






final class RuntimeStepTester implements StepTester
{



private $definitionFinder;



private $callCenter;







public function __construct(DefinitionFinder $definitionFinder, CallCenter $callCenter)
{
$this->definitionFinder = $definitionFinder;
$this->callCenter = $callCenter;
}




public function setUp(Environment $env, FeatureNode $feature, StepNode $step, $skip)
{
return new SuccessfulSetup();
}




public function test(Environment $env, FeatureNode $feature, StepNode $step, $skip = false)
{
try {
$search = $this->searchDefinition($env, $feature, $step);
$result = $this->testDefinition($env, $feature, $step, $search, $skip);
} catch (SearchException $exception) {
$result = new FailedStepSearchResult($exception);
}

return $result;
}




public function tearDown(Environment $env, FeatureNode $feature, StepNode $step, $skip, StepResult $result)
{
return new SuccessfulTeardown();
}










private function searchDefinition(Environment $env, FeatureNode $feature, StepNode $step)
{
return $this->definitionFinder->findDefinition($env, $feature, $step);
}












private function testDefinition(Environment $env, FeatureNode $feature, StepNode $step, SearchResult $search, $skip)
{
if (!$search->hasMatch()) {
return new UndefinedStepResult();
}

if ($skip) {
return new SkippedStepResult($search);
}

$call = $this->createDefinitionCall($env, $feature, $search, $step);
$result = $this->callCenter->makeCall($call);

return new ExecutedStepResult($search, $